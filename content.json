{"meta":{"title":"Eleven's Blog","subtitle":null,"description":"Insist on learning some technology every day.","author":"Eleven","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-08-28T05:38:59.000Z","updated":"2019-08-28T05:39:59.284Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-28T09:25:25.000Z","updated":"2019-08-28T09:43:03.555Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"在校大学生记录学到的知识"},{"title":"标签","date":"2019-08-28T05:35:05.000Z","updated":"2019-08-29T04:36:47.381Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"39-组合总和，77-组合，78-子集","slug":"39-组合总和，77-组合，78-子集","date":"2020-01-14T08:03:29.000Z","updated":"2020-01-14T08:31:52.693Z","comments":true,"path":"2020/01/14/39-组合总和，77-组合，78-子集/","link":"","permalink":"http://yoursite.com/2020/01/14/39-组合总和，77-组合，78-子集/","excerpt":"","text":"递归回溯39. 组合总和 class Solution { List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { if (candidates == null || candidates.length == 0 || target &lt; 0) { return lists; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); process(0, candidates, target, list); return lists; } private void process(int start, int[] candidates, int target, List&lt;Integer&gt; list) { //递归的终止条件 if (target &lt; 0) { return; } if (target == 0) { lists.add(new ArrayList&lt;&gt;(list)); } else { for (int i = start; i &lt; candidates.length; i++) { list.add(candidates[i]); //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始 process(i, candidates, target - candidates[i], list); list.remove(list.size() - 1); } } } }77. 组合 class Solution { private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { if(n &lt;= 0 || k &lt;= 0 || n &lt; k) return res; findCombination(n,k,1,new Stack&lt;&gt;()); return res; } private void findCombination(int n,int k,int first,List&lt;Integer&gt; pre){ if(pre.size()==k){ res.add(new ArrayList&lt;&gt;(pre)); } for(int i=first;i&lt;=n;i++){ pre.add(i); findCombination(n,k,i+1,pre); pre.remove(pre.size()-1); } } }78. 子集 class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { if(nums == null || nums.length ==0){ return res; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Combine(list,0,nums); return res; } public void Combine(List&lt;Integer&gt; list,int start,int[] nums){ res.add(new ArrayList(list)); for(int i=start;i&lt;nums.length;i++){ list.add(nums[i]); Combine(list,i+1,nums); list.remove(list.size()-1); } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Hbase完全分布式搭建与实践","slug":"Hbase完全分布式搭建与实践","date":"2020-01-13T12:03:32.000Z","updated":"2020-01-13T13:09:45.144Z","comments":true,"path":"2020/01/13/Hbase完全分布式搭建与实践/","link":"","permalink":"http://yoursite.com/2020/01/13/Hbase完全分布式搭建与实践/","excerpt":"","text":"Hbase系统架构关于Hbase1、HBase是Google Bigtable的开源实现，它利用Hadoop HDFS作为其文件存储系统，利用Hadoop MapReduce来处理，HBase中的海量数据，利用Zookeeper作为协同服务。2、HBase是一种构建在HDFS之上的分布式、面向列的存储系统。1、Hmaster负责管理Hbase的元数据，表结构，表的Region信息负责表的创建，删除和修改负责为HRegionServer分配Region，分配后将元数据写入相应位置 2、HRegionServer含有多个HRegion处理Client端的读写请求（根据从HMaster返回的元数据找到对应的HRegionServer）管理Region的Split分裂、StoreFile的Compaction合并。 3、HRegion一个HRegion里可能有1个或多个StoreHRegionServer维护一个HLogHRegion是分布式存储和负载的最小单元。表通常被保存在多个HRegionServer的多个Region中 4、StoreStore是存储落盘的最小单元，由内存中的MemStore和磁盘中的若干StoreFile组成一个Store里有1个或多个StoreFile和一个memStore每个Store存储一个列族 Hbase完全分布式环境搭建虚拟机数量：3台操作系统：Ubuntu 14.04.3 实验环境及版本：Java：openjdk version “1.8.0_222”Hadoop：Hadoop 2.7.1Zookeeper:zookeeper-3.5.6.tar.gzHBase：hbase 1.1.2 环境搭建顺序 Hbase数据分析1、数据集介绍数据集来源http://dataju.cn/Dataju/web/datasetInstanceDetail/226数据包括IMDB网站上抓取的4973部电影28个属性信息,电影时间跨度超过100年和66个国家。属性包括：电影名称、评分、上映时间、上映国家、主要演员、语言、IMDB评分等。 2、数据集处理在第一列加上自动增长的序列，作为Hbase的row_key 3、导入数据集① 先下载.csv格式的数据到本地② 上传数据文件到Hdfs③ 在HBase里面创建一个movie表来存放电影数据④ 利用ImportTsv将HDFS上的数据文件导入到Hbase的movie表中 4、数据分析首先开启hbase shell,然后再Eclipse中编写java代码连接HBase分析数据Eclipse编写分析程序GitHub源码https://github.com/Eleven-is-cool/DataAnalyzeInHbaseEclipse中导入可视化分析相关包，编写代码分析！ BUG合集1、netstat -antp | grep 进程号 根据需要查看进程的访问端口2、单个节点处理Hmaster或者Hregionserver在regionServer上./hbase-daemon.sh start regionserver在master上执行：./hbase-daemon.sh start master3、进入hbase Shell后若出现ERROR: Can&#39;t get master address from ZooKeeper; znode data == null解决方法之一：ip和端口必须一样4、导入数据hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.separator=”,” -Dimporttsv.columns=HBASE_ROW_KEY,info:color,info:director_name,info: num_critic_for_reviews,info:duration,info:director_facebook_likes,info: actor_3_facebook_likes,info:actor_2_name,info:actor_1_facebook_likes hbase-csv1 /small.csv5、在Excel中添加第一列填充序号","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"'HDFS文件系统'","slug":"HDFS文件系统","date":"2020-01-13T10:32:24.000Z","updated":"2020-01-13T10:54:39.400Z","comments":true,"path":"2020/01/13/HDFS文件系统/","link":"","permalink":"http://yoursite.com/2020/01/13/HDFS文件系统/","excerpt":"","text":"分布式文件系统计算机集群结构分布式文件系统把文件分布存储到多个计算机节点上，成千上万的计算机节点构成计算机集群与之前使用多个处理器和专用高级硬件的并行化处理装置不同的是，目前的分布式文件系统所采用的计算机集群，都是由普通硬件构成的，这就大大降低了硬件上的开销 分布式文件系统的结构分布式文件系统在物理结构上是由计算机集群中的多个节点构成的，这些节点分为两类，一类叫“主节点”(Master Node)或者也被称为“名称结点”(NameNode)，另一类叫“从节点”（Slave Node）或者也被称为“数据节点”(DataNode) HDFS简介总体而言，HDFS要实现以下目标：●兼容廉价的硬件设备●流数据读写●大数据集●简单的文件模型●强大的跨平台兼容性HDFS特殊的设计，在实现上述优良特性的同时，也使得自身具有一些应用局限性，主要包括以下几个方面：●不适合低延迟数据访问●无法高效存储大量小文件●不支持多用户写入及任意修改文件 HDFS相关概念块HDFS默认一个块64MB，一个文件被分成多个块，以块作为存储单位块的大小远远大于普通文件系统，可以最小化寻址开销HDFS采用抽象的块概念可以带来以下几个明显的好处：● 支持大规模文件存储：文件以块为单位进行存储，一个大规模文件可以被分拆成若干个文件块，不同的文件块可以被分发到不同的节点上，因此，一个文件的大小不会受到单个节点的存储容量的限制，可以远远大于网络中任意节点的存储容量● 简化系统设计：首先，大大简化了存储管理，因为文件块大小是固定的，这样就可以很容易计算出一个节点可以存储多少文件块；其次，方便了元数据的管理，元数据不需要和文件块一起存储，可以由其他系统负责管理元数据● 适合数据备份：每个文件块都可以冗余存储到多个节点上，大大提高了系统的容错性和可用性 名称节点和数据节点名字节点-NameNode:管理元数据信息管理系统命名空间监听并处理请求心跳检测空间回收/冗余控制数据节点-DataNode:读写数据块报告状态-NameNode数据块复制-流水线 名称节点的数据结构在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），保存了两个核心的数据结构，即FsImage和EditLogFsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作名称节点记录了每个文件中各个块所在的数据节点的位置信息 名称节点运行期间EditLog不断变大的问题在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文件将会变得很大 虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用 如何解决？答案是：SecondaryNameNode第二名称节点 第二名称节点是HDFS架构中的一个组成部分，它是用来保存名称节点中对HDFS 元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上 SecondaryNameNode的工作情况：（1）SecondaryNameNode会定期和NameNode通信，请求其停止使用EditLog文件，暂时将新的写操作写到一个新的文件edit.new上来，这个操作是瞬间完成，上层写日志的函数完全感觉不到差别；（2）SecondaryNameNode通过HTTP GET方式从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下；（3）SecondaryNameNode将下载下来的FsImage载入到内存，然后一条一条地执行EditLog文件中的各项更新操作，使得内存中的FsImage保持最新；这个过程就是EditLog和FsImage文件合并；（4）SecondaryNameNode执行完（3）操作之后，会通过post方式将新的FsImage文件发送到NameNode节点上（5）NameNode将从SecondaryNameNode接收到的新的FsImage替换旧的FsImage文件，同时将edit.new替换EditLog文件，通过这个过程EditLog就变小了 HDFS体系结构HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点（NameNode）和若干个数据节点（DataNode）。名称节点作为中心服务器，负责管理文件系统的命名空间及客户端对文件的访问。集群中的数据节点一般是一个节点运行一个数据节点进程，负责处理文件系统客户端的读/写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作。每个数据节点的数据实际上是保存在本地Linux文件系统中的HDFS是一个部署在集群上的分布式文件系统，因此，很多数据需要通过网络进行传输所有的HDFS通信协议都是构建在TCP/IP协议基础之上的客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互名称节点和数据节点之间则使用数据节点协议进行交互客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求 HDFS存储原理作为一个分布式文件系统，为了保证系统的容错性和可用性，HDFS采用了多副本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上，如图3-5所示，数据块1被分别存放到数据节点A和C上，数据块2被存放在数据节点A和B上。这种多副本方式具有以下几个优点：（1）加快数据传输速度（2）容易检查数据错误（3）保证数据可靠性 数据存放第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点第二个副本：放置在与第一个副本不同的机架的节点上第三个副本：与第一个副本相同机架的其他节点上更多副本：随机节点 数据读取HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"Hadoop","slug":"Hadoop","date":"2020-01-13T09:16:22.000Z","updated":"2020-01-13T10:31:12.445Z","comments":true,"path":"2020/01/13/Hadoop/","link":"","permalink":"http://yoursite.com/2020/01/13/Hadoop/","excerpt":"","text":"Hadoop简介Hadoop是Apache软件基金会旗下的一个开源分布式计算平台，为用户提了系统底层细节透明的分布式基础架构。Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。Hadoop的核心是分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce。Hadoop最初是由Apache Lucene项目的创始人Doug Cutting开发的文本搜索库。Hadoop源自始于2002年的Apache Nutch项目——一个开源的网络搜索引擎并且也是Lucene项目的一部分。 Hadoop的特性Hadoop是一个能够对大量数据进行分布式处理的软件框架，并且是以一种可靠、高效、可伸缩的方式进行处理的，它具有以下几个方面的特性：高可靠性高效性高可扩展性高容错性成本低运行在Linux平台上支持多种编程语言 Hadoop的项目结构","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"大数据时代","slug":"大数据时代","date":"2020-01-13T05:26:42.000Z","updated":"2020-01-13T11:43:51.398Z","comments":true,"path":"2020/01/13/大数据时代/","link":"","permalink":"http://yoursite.com/2020/01/13/大数据时代/","excerpt":"","text":"大数据时代的来临三次信息化浪潮数据产生方式的变革促成大数据时代的来临。 传统关系型数据库面临的问题关系模型束缚对海量数据的快速访问能力传统按值定位相应的行的方式，影响快速访问的能力在海量数据下分区也无法显著改善性能 缺乏海量数据访问的灵活性不能对随机性的查询快速响应，需要DBA对系统调优 对非结构数据处理能力薄弱对多媒体数据只是停留在二进制代码文件的存储无法应对多媒体数据的识别、检索等深加工需求 海量数据导致存储成本、维护成本不断增加海量数据导致的存储和维护成本直线上升 大数据的特点①数据量大 ②数据类型繁多 ③处理速度快 ④价值密度低 大数据三大基石①Bigtable ②HDFS ③MapReduce NoSql通常，NoSQL数据库具有以下几个特点：（1）灵活的可扩展性（2）灵活的数据模型（3）与云计算紧密融合 NoSQL与关系数据库的比较总结（1）关系数据库优势：以完善的关系代数理论作为基础，有严格的标准，支持事务ACID四性，借助索引机制可以实现高效的查询，技术成熟，有专业公司的技术支持劣势：可扩展性较差，无法较好支持海量数据存储，数据模型过于死板、无法较好支持Web2.0应用，事务机制影响了系统的整体性能等 （2）NoSQL数据库优势：可以支持超大规模数据存储，灵活的数据模型可以很好地支持Web2.0应用，具有强大的横向扩展能力等劣势：缺乏数学理论基础，复杂查询性能不高，大都不能实现事务强一致性，很难实现数据完整性，技术尚不成熟，缺乏专业团队的技术支持，维护较困难等 NoSQL的四大类型","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"AlexNet","slug":"AlexNet","date":"2019-12-07T08:27:19.000Z","updated":"2020-01-13T11:01:21.926Z","comments":true,"path":"2019/12/07/AlexNet/","link":"","permalink":"http://yoursite.com/2019/12/07/AlexNet/","excerpt":"","text":"2012年AlexNet在ImageNet大赛上一举夺魁，开启了深度学习的时代，虽然后来大量比AlexNet更快速更准确的卷积神经网络结构相继出现，但是AlexNet作为开创者依旧有着很多值得学习参考的地方，它为后续的CNN甚至是R-CNN等其他网络都定下了基调，所以下面我们将从AlexNet入手，理解卷积神经网络的一般结构。Alexnet网络是由八层网络组成的，包括5层卷积层和3层全连接层，下面是详细的介绍：第一层：Alexnet的输入部分是224 * 224 * 3的彩色图片，经过预处理之后，变为227 * 227 * 3的大小，作为网络的输入的部分。这个图像被96个大小规格为11 * 11 * 3的卷积核，进行特征提取，96个卷积核分成2组（因为采用了2个GPU服务器进行处理），每组48个卷积核；因此，卷积核在移动的过程中会生成(227-11)/4+1=55个像素，注意这里提取到的特征图是彩色的。这样得到了96个55 * 55大小的特征图了，并且是RGB通道的.96个卷积核分成2组，每组48个卷积核。对应生成2组55 * 55 * 48的卷积后的像素层数据。这些像素层经过relu1单元的处理，生成激活像素层，尺寸仍为2组55 * 55 * 48的像素层数据。这些像素层经过pool运算(最大池化)的处理，池化运算的尺度为3 * 3，stride移动的步长为2，则池化后图像的尺寸为(55-3)/2+1=27。 即池化后像素的规模为27 * 27 * 96；然后经过归一化处理，归一化运算的尺度为5 * 5；第一卷积层运算结束后形成的像素层的规模为27 * 27 * 96。分别对应96个卷积核所运算形成。这96层像素层分为2组，每组48个像素层，每组在一个独立的GPU上进行运算。 第二层：输入数据为第一层输出的27 * 27 * 96的像素层，为便于后续处理，每幅像素层的左右两边和上下两边都要填充2个像素；27 * 27 * 96的像素数据分成27 * 27 * 48的两组像素数据，两组数据分别再两个不同的GPU中进行运算，每组像素数据被5 * 5 * 48的卷积核进行卷积运算，卷积核对每组数据的每次卷积都生成一个新的像素。在卷积的过程中，因为步长是1个像素。因此，卷积核在移动的过程中会生成(27-5+2 * 2)/1+1=27个像素。共有256个5 * 5 * 48卷积核；这256个卷积核分成两组，每组针对一个GPU中的27 * 27 * 48的像素进行卷积运算。会生成两组27 * 27 * 128个卷积后的像素层。这些像素层经过relu2单元的处理，生成激活像素层，尺寸仍为两组27 * 27 * 128的像素层。这些像素层经过pool运算(最大池化)的处理，池化运算的尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(27-3)/2+1=13。 即池化后像素的规模为2组13 * 13 * 128的像素层。最后经过归一化处理，归一化运算的尺度为5 * 5；第二卷积层运算结束后形成的像素层的规模为2组13 * 13 * 128的像素层。 第三层：第三层没有使用池化层，只有一个卷积层与另外一个激活函数。输入数据为第二层输出的2组13 * 13 * 128的像素层，为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；2组像素层数据都被送至2个不同的GPU中进行运算；因为在这里做了通道的合并，也就是一种串接操作，所以一个卷积核卷积的不再是单张显卡上的图像，而是两张显卡的图像串在一起之后的图像，串在一起之后的通道数就是256，所以卷积核的厚度为256，每个卷积核的尺寸是3 * 3 * 256，移动的步长是1个像素。运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13。2个GPU中共13 * 13 * 384个卷积后的像素层。这些像素层经过relu3单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 192像素层，共13 * 13 * 384个像素层。 第四层：没有使用池化层。输入数据为第三层输出的2组13 * 13 * 192的像素层；为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有192个卷积核，共384个，每个卷积核的尺寸是3 * 3 * 192。因此，运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13，2个GPU中共13 * 13 * 384个卷积后的像素层。这些像素层经过relu4单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 192像素层，共13 * 13 * 384个像素层。 第五层：输入数据为第四层输出的2组13 * 13 * 192的像素层；为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有128个卷积核，每个卷积核的尺寸是3 * 3 * 192。移动的步长是1个像素。因此，运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13。2个GPU中共13 * 13 * 256个卷积后的像素层。这些像素层经过relu5单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 128像素层，共13 * 13 * 256个像素层。2组13 * 13 * 128像素层分别在2个不同GPU中进行池化(pool)运算处理。池化运算的尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(13-3)/2+1=6。 即池化后像素的规模为两组6 * 6 * 128的像素层数据，共6 * 6 * 256规模的像素层数据。 第六层：第五层输出的6 * 6 * 256规模的像素层数据与第六层的4096个神经元进行全连接，然后经由relu6进行处理后生成4096个数据，再经过dropout6处理后输出4096个数据。 第七层：第六层输出的4096个数据与第七层的4096个神经元进行全连接，然后经由relu7进行处理后生成4096个数据，再经过dropout7处理后输出4096个数据。 第八层：第七层输出的4096个数据与第八层的1000个神经元进行全连接，经过训练后输出被训练的数值。 参考：https://blog.csdn.net/zyqdragon/article/details/72353420https://blog.csdn.net/chaipp0607/article/details/72847422","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/categories/Machine-Learning/"}],"tags":[]},{"title":"Neo4j","slug":"Neo4j","date":"2019-12-07T05:06:46.000Z","updated":"2019-12-07T08:34:06.410Z","comments":true,"path":"2019/12/07/Neo4j/","link":"","permalink":"http://yoursite.com/2019/12/07/Neo4j/","excerpt":"","text":"Neo4j简介Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。 Neo4j配置与启动首先需要下载neo4j-community-3.5.13-unix.tar.gz定位到文件所在位置，解压 tar -xf neo4j-community-3.5.13-unix.tar.gzmv neo4j-community-3.5.13-unix /home/hadoop/neo4j/home/hadoop/neo4j/bin/neo4j start打开浏览器输入：http://localhost:7474 Neo4j基础操作创建节点CREATE (&lt;node-name&gt;:&lt;label-name&gt;{ &lt;Property1-name&gt;:&lt;Property1-value&gt;...&lt;Propertyn-name&gt;:&lt;Propertyn-value&gt; }),...eg:CREATE (website:Demo{title:&#39;Code&#39;,begin:2019-10-1,end:2019-12-1}) 创建关系CREATE (&lt;node1-name&gt;:&lt;label1-name&gt;)-[(&lt;relationship-name&gt;:&lt;relationship-label-name&gt;)]-&gt;(&lt;node2-name&gt;:&lt;label2-name&gt;)eg:(Hong)-[:TASK_IN{roles:[&#39;boss&#39;]}]-&gt;(website) 获取有关节点与数据MATCH (&lt;node-name&gt;:&lt;label-name&gt;)单独使用无结果 返回结果RETURN &lt;node-name&gt;.&lt;Propertyn-name&gt;单独使用无结果 获取数据并返回结果eg:MATCH (a:Person)-[r:Person_Relate{detial: [&#39;classmate&#39;]}]-&gt;(b:Person) RETURN a,r,b创建节点与关系必须同时在一个命令行执行，否则需要MAtch先定位 ###实际例子 CREATE (website:Demo{title:’Code’,begin:2019-10-1,end:2019-12-1}), (Keanu:Person{name:’Keanu Reeves’,born:1994}), (Carrie:Person {name:’Carrie-Anne Moss’, born:1997}), (Laurence:Person {name:’Laurence Fishburne’, born:1999}), (Anndy:Person {name:’Andy Wachowski’, born:1995}), (Hong:Person{name:’Lan Hong’, born:1980}), (Hong)-[:TASK_IN{roles:[‘boss’]}]-&gt;(website), (Keanu)-[:TASK_IN{roles:[‘Front-end’]}]-&gt;(website), (Carrie)-[:TASK_IN{roles:[‘Back-end’]}]-&gt;(website), (Laurence)-[:TASK_IN{roles:[‘Front-end’]}]-&gt;(website), (Anndy)-[:TASK_IN{roles:[‘Back-end’]}]-&gt;(website), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Keanu), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Carrie), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Laurence), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Anndy), (Carrie)-[:Person_Relate{detial:[‘classmate’]}]-&gt;(Anndy), (Keanu)-[:Person_Relate{detial:[‘classmate’]}]-&gt;(Anndy) match (a) return a查找所有关系 match (a:Person)-[r:Person_Relate{detial:[‘classmate’]}]-&gt;(b:Person) return a,r,b 查找关系为’classmate’的节点 match (a:Person)-[r:TASK_IN{roles:[‘Front-end’]}]-&gt;(b:Demo) return a,r,b 查找在项目中负责前端任务的人 待续…","categories":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://yoursite.com/categories/Neo4j/"}],"tags":[]},{"title":"Selenium框架","slug":"Selenium框架","date":"2019-11-24T06:10:29.000Z","updated":"2019-11-24T07:33:39.840Z","comments":true,"path":"2019/11/24/Selenium框架/","link":"","permalink":"http://yoursite.com/2019/11/24/Selenium框架/","excerpt":"","text":"SeleniumSelenium 是一款强大的基于浏览器的开源自动化测试工具，最初由Jason Huggins 于2004年在ThoughtWorks发起，它提供了一套简单易用的API，模拟浏览器的各种操作，方便各种Web应用的自动化测试。WebDriver通过调用浏览器提供的原生自动化API来驱动浏览器，解决了Selenium的很多疑难杂症。最终 Selenium 和 WebDriver 合并在一起，这就是 Selenium 2.0，有的地方也直接把它称作WebDriver。 selenium与chromedriver的下载cmd pip install selenium点击下载 chromedriver下载完路径放在环境变量上面的Path里面 界面化打开浏览器请求访问from selenium import webdriver driver = webdriver.Chrome() driver.get(detail_url) response = driver.page_source#获得页面源码 driver.quit()无界面化打开浏览器请求访问from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument(&quot;--proxy-server=http://{}&quot;.format(proxy)) #代理 chrome_options.add_argument(&apos;window-size=1920x3000&apos;) #指定浏览器分辨率 chrome_options.add_argument(&apos;--headless&apos;) #无界面化 chrome_options.add_argument(&apos;--disable-gpu&apos;) #谷歌文档提到需要加上这个属性来规避bug chrome_options.add_argument(&apos;blink-settings=imagesEnabled=false&apos;) #不加载图片, 提升速度 driver = webdriver.Chrome(chrome_options=chrome_options) driver.get(detail_url) response = driver.page_source driver.quit()定位页面元素单个元素find_element*多个元素find_elements* id复数定位find_elements_by_id() name复数定位find_elements_by_name() class复数定位find_elements_by_class_name() tag复数定位find_elements_by_tag_name() link复数定位find_elements_by_link_text() partial_link复数定位find_elements_by_partial_link_text() xpath复数定位find_elements_by_xpath() css复数定位find_elements_by_css_selector()eg:first_rows = driver.find_elements_by_css_selector(&quot;.aroundType li&quot;) 操作 from selenium.webdriver import ActionChain # 定位到某处并实现点击操作 ActionChains(driver).move_to_element(first_row).click().perform()#执行动作链actions.perform()","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"LeetCode-75-颜色分类","slug":"LeetCode-75-颜色分类","date":"2019-11-17T05:47:21.000Z","updated":"2019-11-24T07:33:39.807Z","comments":true,"path":"2019/11/17/LeetCode-75-颜色分类/","link":"","permalink":"http://yoursite.com/2019/11/17/LeetCode-75-颜色分类/","excerpt":"","text":"75. 颜色分类(荷兰国旗问题) 思路：沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。 算法初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0. 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2. 初始化当前考虑的元素序号 ：curr = 0. While curr &lt;= p2 : 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。 若 nums[curr] = 1 ：将指针curr右移。 class Solution { public void sortColors(int[] nums) { int p0=0; int p2=nums.length-1; int current=0; int tmp; while(current&lt;=p2){ if(nums[current]==2){ tmp=nums[p2]; nums[p2]=nums[current]; p2--; nums[current]=tmp; } else if(nums[current]==0){ tmp=nums[p0]; nums[p0]=nums[current]; p0++; nums[current]=tmp; current++; } else current++; } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-73-矩阵置零","slug":"LeetCode-73-矩阵置零","date":"2019-11-11T12:34:46.000Z","updated":"2019-11-24T07:33:39.874Z","comments":true,"path":"2019/11/11/LeetCode-73-矩阵置零/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-73-矩阵置零/","excerpt":"","text":"73. 矩阵置零 方法一：遍历矩阵，如果有0出现，则遍历该行该列，对不是0的位置赋予一个标志符，最后再遍历矩阵，把标志符变成0；时间复杂度：O((M×N)×(M+N))空间复杂度：O(1)O(1) class Solution { public void setZeroes(int[][] matrix) { int n = matrix.length; int m = matrix[0].length; int tmp=-100000; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ if(matrix[i][j]==0){ for(int k=0;k&lt;n;k++){ if(matrix[k][j]!=0) matrix[k][j] = tmp; } for(int z=0;z&lt;m;z++){ if(matrix[i][z]!=0) matrix[i][z] = tmp; } } } } for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ if(matrix[i][j]==tmp) matrix[i][j]=0; } } } }方法二：方法一不高效的地方在于我们会重复对同一行或者一列赋零。我们可以推迟对行和列赋零的操作。我们可以用每行和每列的第一个元素作为标记，这个标记用来表示这一行或者这一列是否需要赋零。这意味着对于每个节点不需要访问 M+N 个格子而是只需要对标记点的两个格子赋值。这些标签用于之后对矩阵的更新，如果某行的第一个元素为零就将整行置零，如果某列的第一个元素为零就将整列置零。class Solution { public void setZeroes(int[][] matrix) { int row = matrix.length; int col = matrix[0].length; boolean row0_flag = false; boolean col0_flag = false; // 第一行是否有零 for(int j = 0; j &lt; col; j++) { if(matrix[0][j] == 0) { row0_flag = true; break; } } // 第一列是否有零 for(int i = 0; i &lt; row; i++) { if(matrix[i][0] == 0) { col0_flag = true; break; } } // 把第一行第一列作为标志位 for(int i = 1; i &lt; row; i++) { for(int j = 1; j &lt; col; j++) { if(matrix[i][j] == 0) { matrix[i][0] = matrix[0][j] = 0; } } } // 置0 for(int i = 1; i &lt; row; i++) { for(int j = 1; j &lt; col; j++) { if(matrix[i][0] == 0 || matrix[0][j] == 0) { matrix[i][j] = 0; } } } if(row0_flag) { for(int j = 0; j &lt; col; j++) { matrix[0][j] = 0; } } if(col0_flag) { for(int i = 0; i &lt; row; i++) { matrix[i][0] = 0; } } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-69-x的平方根","slug":"LeetCode-69-x的平方根","date":"2019-11-11T11:59:13.000Z","updated":"2019-11-11T12:02:39.612Z","comments":true,"path":"2019/11/11/LeetCode-69-x的平方根/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-69-x的平方根/","excerpt":"","text":"69. x的平方根 思路：二分查找，所有的数都放在一起考虑，为了照顾到 00 把左边界设置为 00，为了照顾到 11 把右边界设置为 x // 2 + 1。 class Solution { public int mySqrt(int x) { long left=0; long right=x/2+1; while(left &lt; right){ long mid = left+(right-left+1)/2; long square = mid*mid; if(square &gt; x){ right = mid-1; } else{ left=mid; } } return (int)left; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-67-二进制求和","slug":"LeetCode-67-二进制求和","date":"2019-11-11T11:52:03.000Z","updated":"2019-11-11T11:58:20.545Z","comments":true,"path":"2019/11/11/LeetCode-67-二进制求和/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-67-二进制求和/","excerpt":"","text":"67. 二进制求和 class Solution { public String addBinary(String a, String b) { StringBuilder res = new StringBuilder(); int ca=0 ; for(int i=a.length()-1,j=b.length()-1;i&gt;=0||j&gt;=0;i--,j--){ int sum = ca; sum += (i&gt;=0? a.charAt(i)-&apos;0&apos;:0); sum += (j&gt;=0? b.charAt(j)-&apos;0&apos;:0); res.append(sum%2); ca = sum/2; } if(ca == 1) res.append(ca); return res.reverse().toString(); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-66-加一","slug":"LeetCode-66-加一","date":"2019-11-11T11:49:47.000Z","updated":"2019-11-11T11:51:13.831Z","comments":true,"path":"2019/11/11/LeetCode-66-加一/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-66-加一/","excerpt":"","text":"66. 加一 class Solution { public int[] plusOne(int[] digits) { int n = digits.length; for(int i=n-1;i&gt;=0;i--){ digits[i]++; digits[i] = digits[i] %10; if(digits[i] != 0) return digits; } digits = new int[digits.length + 1]; digits[0] = 1; return digits; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-62、63-不同路径I、II，64-最小路径和","slug":"LeetCode-62、63-不同路径I、II","date":"2019-10-19T08:31:28.000Z","updated":"2019-11-11T10:18:04.885Z","comments":true,"path":"2019/10/19/LeetCode-62、63-不同路径I、II/","link":"","permalink":"http://yoursite.com/2019/10/19/LeetCode-62、63-不同路径I、II/","excerpt":"","text":"62. 不同路径思路： 动态规划，每个格子可能的路径等于左边格子加上面的格子。注意，对于第一行或者第一列，由于都是在边界，所以只能为 1。优化：可以用一维数组进行优化，当前的状态只跟上一行的状态和同一行左边的状态有关。所以我们只需要维护上一行的数组，和当前行的数组。 二维数组class Solution { public int uniquePaths(int m, int n) { int[][] path = new int[m][n]; for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i == 0 || j == 0) path[i][j] = 1; else{ path[i][j]= path[i-1][j] + path[i][j-1]; } } } return path[m-1][n-1]; } }一维数组class Solution { public int uniquePaths(int m, int n) { int[] cur = new int[n]; Arrays.fill(cur,1); for (int i = 1; i &lt; m;i++){ for (int j = 1; j &lt; n; j++){ cur[j] += cur[j-1] ; } } return cur[n-1]; } }63. 不同路径 II思路： 因为这道题有了障碍物,所以我们有障碍物的地方到不了就设置为0,注意,针对第一行,或者第一列要重新设置,考虑障碍物的情况! class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid == null) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] res = new int[m][n]; if(obstacleGrid[0][0] == 1) return 0; else res[0][0] = 1; for(int i=1;i&lt;n;i++){ if(obstacleGrid[0][i] != 1) res[0][i] = res[0][i-1]; } for(int j=1;j&lt;m;j++){ if(obstacleGrid[j][0] != 1) res[j][0] = res[j-1][0]; } for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ if(obstacleGrid[i][j] != 1) res[i][j] = res[i][j-1]+res[i-1][j]; } } return res[m-1][n-1]; } }64. 最小路径和 class Solution { public int minPathSum(int[][] grid) { int m=grid.length; int n=grid[0].length; for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i==0&amp;&amp;j==0) continue; else if(i==0) grid[i][j] = grid[i][j] + grid[i][j-1]; else if(j==0) grid[i][j] = grid[i][j] + grid[i-1][j]; else grid[i][j] = Math.min(grid[i][j-1],grid[i-1][j]) + grid[i][j]; } } return grid[m-1][n-1]; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 编写名为SimpleMap的类实现Map接口","slug":"Java-编写名为SimpleMap的类实现Map接口","date":"2019-10-17T02:42:30.000Z","updated":"2019-10-17T02:44:49.566Z","comments":true,"path":"2019/10/17/Java-编写名为SimpleMap的类实现Map接口/","link":"","permalink":"http://yoursite.com/2019/10/17/Java-编写名为SimpleMap的类实现Map接口/","excerpt":"","text":"import java.util.AbstractMap.SimpleEntry; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.Set; public class SimpleMap implements Map{ private int size = 0; private int SLOT; private LinkedList[] bucket=new LinkedList[SLOT]; @Override public int size() { return size; } @Override public boolean isEmpty() { if(size==0) return false; else return true; } @Override public boolean containsKey(Object key) { int index = key.hashCode() % SLOT;//查找在哪个槽 if(index&lt;0)//不能为负数 index=-index; if(bucket[index] != null) return false; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator();//迭代器 while(iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if(entry.getKey().equals(key)) return true; } return false; } @Override public boolean containsValue(Object value) { for(int i=0;i&lt;SLOT;i++) { if(bucket[i] != null) { LinkedList linkedList = bucket[i]; Iterator iterator = linkedList.iterator(); while(iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if(entry.getKey().equals(value)) return true; } } } return false; } @Override public Object get(Object key) { int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; if (bucket[index] == null) return null; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if (entry.getKey().equals(key)) { return entry.getValue(); } } return null; } @Override public Object put(Object key, Object value) { int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; SimpleEntry entry = new SimpleEntry(key, value); Object prev = null; if (bucket[index] == null) bucket[index] = new LinkedList(); LinkedList list = bucket[index]; boolean found = false; ListIterator iterator = list.listIterator(); while (iterator.hasNext()) { SimpleEntry simpleEntry = (SimpleEntry) iterator.next(); if (simpleEntry.equals(entry)) {//一对一 found = true; prev = simpleEntry.getValue(); iterator.set(entry); break; } } if (!found) { size++; bucket[index].add(entry); } return prev; } @Override public Object remove(Object key) { SimpleEntry entry = null; int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; if (bucket[index] == null) return null; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) { SimpleEntry simpleEntry = (SimpleEntry) iterator.next(); if (simpleEntry.getKey().equals(key)) { entry = simpleEntry; iterator.remove(); size--; break; } } return entry; } @Override public void putAll(Map m) { Set set = m.entrySet(); for (Object object : set) { Map.Entry oo = (Map.Entry) object; put(oo.getKey(), oo.getValue()); } } @Override public void clear() { for (Object key : keySet()) { remove(key); } size = 0; } @Override public Set keySet() { Set set = new HashSet(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { set.add(((SimpleEntry) iterator.next()).getKey()); } } } return set; } @Override public Collection values() { List list = new ArrayList(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { list.add(((SimpleEntry) iterator.next()).getValue()); } } } return list; } @Override public Set&lt;Entry&gt; entrySet() { Set set = new HashSet(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { set.add(((SimpleEntry) iterator.next())); } } } return set; } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"LeetCode-61-旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-10-07T07:10:23.000Z","updated":"2019-10-07T07:16:44.103Z","comments":true,"path":"2019/10/07/LeetCode-61-旋转链表/","link":"","permalink":"http://yoursite.com/2019/10/07/LeetCode-61-旋转链表/","excerpt":"","text":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null || head.next == null) return head; int length = 1; ListNode old_tail = head; while(old_tail.next != null){//计算链表带数字的长度 length++; old_tail = old_tail.next; } old_tail.next = head;//构成环 ListNode new_tail = head; // 新的尾部 : (n - k % n - 1)th node // 新的头部 : (n - k % n)th node for(int i = 0;i&lt;length-k%length-1;i++){ new_tail = new_tail.next; } ListNode new_head = new_tail.next; new_tail.next = null;//断开环形成单链表 return new_head; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 遍历字符串String","slug":"Java-遍历字符串String","date":"2019-10-04T06:35:57.000Z","updated":"2019-10-04T06:41:12.874Z","comments":true,"path":"2019/10/04/Java-遍历字符串String/","link":"","permalink":"http://yoursite.com/2019/10/04/Java-遍历字符串String/","excerpt":"","text":"Method One String str = &quot;The Lakers are Champions&quot;; for (int i = 0, n = str.length(); i &lt; n; i++) { char c = str.charAt(i); } Method Two char[] chars = str.toCharArray(); for (int i = 0, n = chars.length; i &lt; n; i++) { char c = chars[i]; }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Python 线程池","slug":"Python-线程池","date":"2019-09-23T12:06:31.000Z","updated":"2019-09-23T12:30:44.150Z","comments":true,"path":"2019/09/23/Python-线程池/","link":"","permalink":"http://yoursite.com/2019/09/23/Python-线程池/","excerpt":"","text":"线程池的原理系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。 线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。 此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。 线程池的使用使用线程池来执行线程任务的步骤如下： ①调用 ThreadPoolExecutor 类的构造器创建一个线程池。 ②定义一个普通函数作为线程任务。 ③调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。 ④当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。 回调函数p.submit(这里异步调用).add_done_callback(回调函数)当线程任务完成后，程序会自动触发回调函数，回调函数会获得线程任务的返回值作为参数。在回调函数里，传进来的参数需要用.result()得到结果。 例子from concurrent.futures import ThreadPoolExecutor # 进程池模块 p = ThreadPoolExecutor(30) for page_url in page_url_list: p.submit(get_detail_page_url, page_url).add_done_callback(detail_page_parser) # 这里的回调函数拿到的是一个对象。 # 先把返回的res得到一个结果。即在前面加上一个res.result(),这个结果就是get_detail_page_url的返回 p.shutdown() #shutdown() 方法，该方法将启动线程池的关闭序列。调用 shutdown() 方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。 #当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"LeetCode 56.合并区间","slug":"LeetCode-56-合并区间","date":"2019-09-16T07:44:05.000Z","updated":"2019-09-16T09:51:01.381Z","comments":true,"path":"2019/09/16/LeetCode-56-合并区间/","link":"","permalink":"http://yoursite.com/2019/09/16/LeetCode-56-合并区间/","excerpt":"","text":"class Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals.length == 0 || intervals == null) return res.toArray(new int[0][]); Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] interval:intervals){ if(interval[0] &lt;= end){ end = Math.max(end, interval[1]); }else{ res.add(new int[]{start, end}); start = interval[0]; end = interval[1]; } } res.add(new int[]{start, end}); return res.toArray(new int[0][]); } }修改Arrays.sortclass Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals.length == 0 || intervals == null) return res.toArray(new int[0][]); Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // TODO Auto-generated method stub return o1[0] - o2[0]; } }); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] interval:intervals){ if(interval[0] &lt;= end){ end = Math.max(end, interval[1]); }else{ res.add(new int[]{start, end}); start = interval[0]; end = interval[1]; } } res.add(new int[]{start, end}); return res.toArray(new int[0][]); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 反射：框架设计的灵魂","slug":"Java-反射","date":"2019-09-08T14:42:16.000Z","updated":"2019-09-09T05:44:31.543Z","comments":true,"path":"2019/09/08/Java-反射/","link":"","permalink":"http://yoursite.com/2019/09/08/Java-反射/","excerpt":"","text":"反射：框架设计的灵魂框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。反射：将类的各个组件部分封装为其他对象好处：①可以在程序运行过程中，操作这些对象 ②可以解耦，提高程序的可扩展性 Java代码经历的三阶段：Source源代码阶段——&gt;Class类对象阶段——&gt;Runtime运行时阶段 获取Class对象的方法：1.Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义咋配置文件中。读取文件，加载类2.类名.class：通过类名的属性class获取 * 多用于参数的传递3.对象.getClass():getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 结论： 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方法获取的Class对象都是同一个。 Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java input and inputMismatchException","slug":"Java-input-and-inputMismatchException","date":"2019-09-04T04:27:43.000Z","updated":"2019-09-04T04:47:56.945Z","comments":true,"path":"2019/09/04/Java-input-and-inputMismatchException/","link":"","permalink":"http://yoursite.com/2019/09/04/Java-input-and-inputMismatchException/","excerpt":"","text":"Java从控制台输入常用方法之一：import java.util.Scanner;Scanner scan = new Scanner(System.in);int a = scan.nextInt();String b = scan.nextLine();float c = scan.nextFloat(); 出现inputMismatchException：说明可能输入值与变量声明的数据类型不符合","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"git出现仓库间差异时，可以强推","slug":"git出现仓库间差异时，可以强推","date":"2019-09-03T00:41:06.000Z","updated":"2019-09-04T04:47:56.954Z","comments":true,"path":"2019/09/03/git出现仓库间差异时，可以强推/","link":"","permalink":"http://yoursite.com/2019/09/03/git出现仓库间差异时，可以强推/","excerpt":"","text":"git push -f origin master目前还不知道有什么弊端","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"使用git将本地仓库推送到GitHub仓库","slug":"用git将本地仓库推送到GitHub仓库","date":"2019-08-29T04:08:29.000Z","updated":"2019-08-29T04:36:33.119Z","comments":true,"path":"2019/08/29/用git将本地仓库推送到GitHub仓库/","link":"","permalink":"http://yoursite.com/2019/08/29/用git将本地仓库推送到GitHub仓库/","excerpt":"","text":"创建本地仓库mkdir filenamecd filename 初始化仓库git init然后打开仓库所在的文件夹对文件进行操作 将文件推送本地仓库git status此时会列出带红色的文件名git add 文件名git commit -m &quot;描述&quot;git status提示nothing to commit, working tree clean说明已经没有文件在暂存区和工作区了 推送到远程仓库先到GitHub上创建一个新仓库,复制仓库地址git remote add origin 仓库地址git pull --rebase origin master这一步是为了本地仓库同步远程仓库的README.mdgit push -u origin master第一次推送 对文件修改后，再次推送到远程仓库git statusgit add filenamegit commit -m &quot;描述&quot;git statusgit push origin master推送成功","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"搭建hexo，部署到GitHub仓库","slug":"搭建hexo，部署到GitHub仓库","date":"2019-08-27T13:48:10.000Z","updated":"2019-08-29T03:43:29.846Z","comments":true,"path":"2019/08/27/搭建hexo，部署到GitHub仓库/","link":"","permalink":"http://yoursite.com/2019/08/27/搭建hexo，部署到GitHub仓库/","excerpt":"","text":"首先下载node.js点击进入：https://nodejs.org/en/检查是否下载成功 接着安装hexo博客框架安装hexo博客框架，需要借助npm包管理器来安装，国内镜像安装比较慢，先用npm下载cnpm，就是淘宝源，利用淘宝源来安装加快下载速度。检查是否下载成功接下来利用cnpm安装hexo框架检查是否安装成功 初始化hexo博客查看路径创建一个新文件夹然后进入该路径初始化博客查看blog文件夹，是否下载成功启动博客在浏览器访问一下，访问成功，说明博客已经在本地成功搭建创建一篇博客，先关闭博客。查看路径下的文件对于博客内容，可以在文件夹里用typora打开编辑，然后保存刷新即可。接着清理生成再次启动博客刷新浏览器页面就可以看到你刚刚的那篇博文 将博客部署到远端，使别人能访问在blog目录下装一个git部署插件接下来对blog文件夹里的_config.yml进行添加说明，可以选择用文本打开，滚到最底部，将deploy下面的内容补上去，每一行开头前两个空格，冒号后面一个空格，repo是你仓库的地址。保存退出，接着部署到远端中间需要输入你GitHub的账户密码接下来就可以根据你的仓库名（name.github.io）访问你的博客了","categories":[],"tags":[]}]}