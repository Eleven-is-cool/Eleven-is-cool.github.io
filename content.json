{"meta":{"title":"Eleven's Blog","subtitle":null,"description":"Insist on learning some technology every day.","author":"Eleven","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-08-28T09:25:25.000Z","updated":"2019-08-28T09:43:03.555Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"在校大学生记录学到的知识"},{"title":"分类","date":"2019-08-28T05:38:59.000Z","updated":"2019-08-28T05:39:59.284Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-28T05:35:05.000Z","updated":"2019-08-29T04:36:47.381Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-62、63-不同路径I、II","slug":"LeetCode-62、63-不同路径I、II","date":"2019-10-19T08:31:28.000Z","updated":"2019-10-19T08:50:34.183Z","comments":true,"path":"2019/10/19/LeetCode-62、63-不同路径I、II/","link":"","permalink":"http://yoursite.com/2019/10/19/LeetCode-62、63-不同路径I、II/","excerpt":"","text":"62. 不同路径思路： 动态规划，每个格子可能的路径等于左边格子加上面的格子。注意，对于第一行或者第一列，由于都是在边界，所以只能为 1。优化：可以用一维数组进行优化，当前的状态只跟上一行的状态和同一行左边的状态有关。所以我们只需要维护上一行的数组，和当前行的数组。 二维数组class Solution { public int uniquePaths(int m, int n) { int[][] path = new int[m][n]; for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i == 0 || j == 0) path[i][j] = 1; else{ path[i][j]= path[i-1][j] + path[i][j-1]; } } } return path[m-1][n-1]; } }一维数组class Solution { public int uniquePaths(int m, int n) { int[] cur = new int[n]; Arrays.fill(cur,1); for (int i = 1; i &lt; m;i++){ for (int j = 1; j &lt; n; j++){ cur[j] += cur[j-1] ; } } return cur[n-1]; } }63. 不同路径 II思路： 因为这道题有了障碍物,所以我们有障碍物的地方到不了就设置为0,注意,针对第一行,或者第一列要重新设置,考虑障碍物的情况! class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid == null) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] res = new int[m][n]; if(obstacleGrid[0][0] == 1) return 0; else res[0][0] = 1; for(int i=1;i&lt;n;i++){ if(obstacleGrid[0][i] != 1) res[0][i] = res[0][i-1]; } for(int j=1;j&lt;m;j++){ if(obstacleGrid[j][0] != 1) res[j][0] = res[j-1][0]; } for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ if(obstacleGrid[i][j] != 1) res[i][j] = res[i][j-1]+res[i-1][j]; } } return res[m-1][n-1]; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 编写名为SimpleMap的类实现Map接口","slug":"Java-编写名为SimpleMap的类实现Map接口","date":"2019-10-17T02:42:30.000Z","updated":"2019-10-17T02:44:49.566Z","comments":true,"path":"2019/10/17/Java-编写名为SimpleMap的类实现Map接口/","link":"","permalink":"http://yoursite.com/2019/10/17/Java-编写名为SimpleMap的类实现Map接口/","excerpt":"","text":"import java.util.AbstractMap.SimpleEntry; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.Set; public class SimpleMap implements Map{ private int size = 0; private int SLOT; private LinkedList[] bucket=new LinkedList[SLOT]; @Override public int size() { return size; } @Override public boolean isEmpty() { if(size==0) return false; else return true; } @Override public boolean containsKey(Object key) { int index = key.hashCode() % SLOT;//查找在哪个槽 if(index&lt;0)//不能为负数 index=-index; if(bucket[index] != null) return false; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator();//迭代器 while(iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if(entry.getKey().equals(key)) return true; } return false; } @Override public boolean containsValue(Object value) { for(int i=0;i&lt;SLOT;i++) { if(bucket[i] != null) { LinkedList linkedList = bucket[i]; Iterator iterator = linkedList.iterator(); while(iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if(entry.getKey().equals(value)) return true; } } } return false; } @Override public Object get(Object key) { int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; if (bucket[index] == null) return null; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if (entry.getKey().equals(key)) { return entry.getValue(); } } return null; } @Override public Object put(Object key, Object value) { int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; SimpleEntry entry = new SimpleEntry(key, value); Object prev = null; if (bucket[index] == null) bucket[index] = new LinkedList(); LinkedList list = bucket[index]; boolean found = false; ListIterator iterator = list.listIterator(); while (iterator.hasNext()) { SimpleEntry simpleEntry = (SimpleEntry) iterator.next(); if (simpleEntry.equals(entry)) {//一对一 found = true; prev = simpleEntry.getValue(); iterator.set(entry); break; } } if (!found) { size++; bucket[index].add(entry); } return prev; } @Override public Object remove(Object key) { SimpleEntry entry = null; int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; if (bucket[index] == null) return null; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) { SimpleEntry simpleEntry = (SimpleEntry) iterator.next(); if (simpleEntry.getKey().equals(key)) { entry = simpleEntry; iterator.remove(); size--; break; } } return entry; } @Override public void putAll(Map m) { Set set = m.entrySet(); for (Object object : set) { Map.Entry oo = (Map.Entry) object; put(oo.getKey(), oo.getValue()); } } @Override public void clear() { for (Object key : keySet()) { remove(key); } size = 0; } @Override public Set keySet() { Set set = new HashSet(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { set.add(((SimpleEntry) iterator.next()).getKey()); } } } return set; } @Override public Collection values() { List list = new ArrayList(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { list.add(((SimpleEntry) iterator.next()).getValue()); } } } return list; } @Override public Set&lt;Entry&gt; entrySet() { Set set = new HashSet(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { set.add(((SimpleEntry) iterator.next())); } } } return set; } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"LeetCode-61-旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-10-07T07:10:23.000Z","updated":"2019-10-07T07:16:44.103Z","comments":true,"path":"2019/10/07/LeetCode-61-旋转链表/","link":"","permalink":"http://yoursite.com/2019/10/07/LeetCode-61-旋转链表/","excerpt":"","text":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null || head.next == null) return head; int length = 1; ListNode old_tail = head; while(old_tail.next != null){//计算链表带数字的长度 length++; old_tail = old_tail.next; } old_tail.next = head;//构成环 ListNode new_tail = head; // 新的尾部 : (n - k % n - 1)th node // 新的头部 : (n - k % n)th node for(int i = 0;i&lt;length-k%length-1;i++){ new_tail = new_tail.next; } ListNode new_head = new_tail.next; new_tail.next = null;//断开环形成单链表 return new_head; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 遍历字符串String","slug":"Java-遍历字符串String","date":"2019-10-04T06:35:57.000Z","updated":"2019-10-04T06:41:12.874Z","comments":true,"path":"2019/10/04/Java-遍历字符串String/","link":"","permalink":"http://yoursite.com/2019/10/04/Java-遍历字符串String/","excerpt":"","text":"Method One String str = &quot;The Lakers are Champions&quot;; for (int i = 0, n = str.length(); i &lt; n; i++) { char c = str.charAt(i); } Method Two char[] chars = str.toCharArray(); for (int i = 0, n = chars.length; i &lt; n; i++) { char c = chars[i]; }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Python 线程池","slug":"Python-线程池","date":"2019-09-23T12:06:31.000Z","updated":"2019-09-23T12:30:44.150Z","comments":true,"path":"2019/09/23/Python-线程池/","link":"","permalink":"http://yoursite.com/2019/09/23/Python-线程池/","excerpt":"","text":"线程池的原理系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。 线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。 此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。 线程池的使用使用线程池来执行线程任务的步骤如下： ①调用 ThreadPoolExecutor 类的构造器创建一个线程池。 ②定义一个普通函数作为线程任务。 ③调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。 ④当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。 回调函数p.submit(这里异步调用).add_done_callback(回调函数)当线程任务完成后，程序会自动触发回调函数，回调函数会获得线程任务的返回值作为参数。在回调函数里，传进来的参数需要用.result()得到结果。 例子from concurrent.futures import ThreadPoolExecutor # 进程池模块 p = ThreadPoolExecutor(30) for page_url in page_url_list: p.submit(get_detail_page_url, page_url).add_done_callback(detail_page_parser) # 这里的回调函数拿到的是一个对象。 # 先把返回的res得到一个结果。即在前面加上一个res.result(),这个结果就是get_detail_page_url的返回 p.shutdown() #shutdown() 方法，该方法将启动线程池的关闭序列。调用 shutdown() 方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。 #当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"LeetCode 56.合并区间","slug":"LeetCode-56-合并区间","date":"2019-09-16T07:44:05.000Z","updated":"2019-09-16T09:51:01.381Z","comments":true,"path":"2019/09/16/LeetCode-56-合并区间/","link":"","permalink":"http://yoursite.com/2019/09/16/LeetCode-56-合并区间/","excerpt":"","text":"class Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals.length == 0 || intervals == null) return res.toArray(new int[0][]); Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] interval:intervals){ if(interval[0] &lt;= end){ end = Math.max(end, interval[1]); }else{ res.add(new int[]{start, end}); start = interval[0]; end = interval[1]; } } res.add(new int[]{start, end}); return res.toArray(new int[0][]); } }修改Arrays.sortclass Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals.length == 0 || intervals == null) return res.toArray(new int[0][]); Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // TODO Auto-generated method stub return o1[0] - o2[0]; } }); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] interval:intervals){ if(interval[0] &lt;= end){ end = Math.max(end, interval[1]); }else{ res.add(new int[]{start, end}); start = interval[0]; end = interval[1]; } } res.add(new int[]{start, end}); return res.toArray(new int[0][]); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 反射：框架设计的灵魂","slug":"Java-反射","date":"2019-09-08T14:42:16.000Z","updated":"2019-09-09T05:44:31.543Z","comments":true,"path":"2019/09/08/Java-反射/","link":"","permalink":"http://yoursite.com/2019/09/08/Java-反射/","excerpt":"","text":"反射：框架设计的灵魂框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。反射：将类的各个组件部分封装为其他对象好处：①可以在程序运行过程中，操作这些对象 ②可以解耦，提高程序的可扩展性 Java代码经历的三阶段：Source源代码阶段——&gt;Class类对象阶段——&gt;Runtime运行时阶段 获取Class对象的方法：1.Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义咋配置文件中。读取文件，加载类2.类名.class：通过类名的属性class获取 * 多用于参数的传递3.对象.getClass():getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 结论： 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方法获取的Class对象都是同一个。 Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java input and inputMismatchException","slug":"Java-input-and-inputMismatchException","date":"2019-09-04T04:27:43.000Z","updated":"2019-09-04T04:47:56.945Z","comments":true,"path":"2019/09/04/Java-input-and-inputMismatchException/","link":"","permalink":"http://yoursite.com/2019/09/04/Java-input-and-inputMismatchException/","excerpt":"","text":"Java从控制台输入常用方法之一：import java.util.Scanner;Scanner scan = new Scanner(System.in);int a = scan.nextInt();String b = scan.nextLine();float c = scan.nextFloat(); 出现inputMismatchException：说明可能输入值与变量声明的数据类型不符合","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"git出现仓库间差异时，可以强推","slug":"git出现仓库间差异时，可以强推","date":"2019-09-03T00:41:06.000Z","updated":"2019-09-04T04:47:56.954Z","comments":true,"path":"2019/09/03/git出现仓库间差异时，可以强推/","link":"","permalink":"http://yoursite.com/2019/09/03/git出现仓库间差异时，可以强推/","excerpt":"","text":"git push -f origin master目前还不知道有什么弊端","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"使用git将本地仓库推送到GitHub仓库","slug":"用git将本地仓库推送到GitHub仓库","date":"2019-08-29T04:08:29.000Z","updated":"2019-08-29T04:36:33.119Z","comments":true,"path":"2019/08/29/用git将本地仓库推送到GitHub仓库/","link":"","permalink":"http://yoursite.com/2019/08/29/用git将本地仓库推送到GitHub仓库/","excerpt":"","text":"创建本地仓库mkdir filenamecd filename 初始化仓库git init然后打开仓库所在的文件夹对文件进行操作 将文件推送本地仓库git status此时会列出带红色的文件名git add 文件名git commit -m &quot;描述&quot;git status提示nothing to commit, working tree clean说明已经没有文件在暂存区和工作区了 推送到远程仓库先到GitHub上创建一个新仓库,复制仓库地址git remote add origin 仓库地址git pull --rebase origin master这一步是为了本地仓库同步远程仓库的README.mdgit push -u origin master第一次推送 对文件修改后，再次推送到远程仓库git statusgit add filenamegit commit -m &quot;描述&quot;git statusgit push origin master推送成功","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"搭建hexo，部署到GitHub仓库","slug":"搭建hexo，部署到GitHub仓库","date":"2019-08-27T13:48:10.000Z","updated":"2019-08-29T03:43:29.846Z","comments":true,"path":"2019/08/27/搭建hexo，部署到GitHub仓库/","link":"","permalink":"http://yoursite.com/2019/08/27/搭建hexo，部署到GitHub仓库/","excerpt":"","text":"首先下载node.js点击进入：https://nodejs.org/en/检查是否下载成功 接着安装hexo博客框架安装hexo博客框架，需要借助npm包管理器来安装，国内镜像安装比较慢，先用npm下载cnpm，就是淘宝源，利用淘宝源来安装加快下载速度。检查是否下载成功接下来利用cnpm安装hexo框架检查是否安装成功 初始化hexo博客查看路径创建一个新文件夹然后进入该路径初始化博客查看blog文件夹，是否下载成功启动博客在浏览器访问一下，访问成功，说明博客已经在本地成功搭建创建一篇博客，先关闭博客。查看路径下的文件对于博客内容，可以在文件夹里用typora打开编辑，然后保存刷新即可。接着清理生成再次启动博客刷新浏览器页面就可以看到你刚刚的那篇博文 将博客部署到远端，使别人能访问在blog目录下装一个git部署插件接下来对blog文件夹里的_config.yml进行添加说明，可以选择用文本打开，滚到最底部，将deploy下面的内容补上去，每一行开头前两个空格，冒号后面一个空格，repo是你仓库的地址。保存退出，接着部署到远端中间需要输入你GitHub的账户密码接下来就可以根据你的仓库名（name.github.io）访问你的博客了","categories":[],"tags":[]}]}