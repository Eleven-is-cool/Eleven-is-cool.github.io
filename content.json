{"meta":{"title":"Eleven's Blog","subtitle":null,"description":"Insist on learning some technology every day.","author":"Eleven","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-08-28T09:25:25.000Z","updated":"2019-08-28T09:43:03.555Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"在校大学生记录学到的知识"},{"title":"标签","date":"2019-08-28T05:35:05.000Z","updated":"2019-08-29T04:36:47.381Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-28T05:38:59.000Z","updated":"2019-08-28T05:39:59.284Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"git上传大文件","slug":"git上传大文件","date":"2020-04-17T06:36:01.000Z","updated":"2020-04-17T06:44:17.557Z","comments":true,"path":"2020/04/17/git上传大文件/","link":"","permalink":"http://yoursite.com/2020/04/17/git上传大文件/","excerpt":"","text":"准备工作如果之前已经commit才提示大文件无法上传，你可能需要先执行这一步，否则直接跳过到下一部分。 重写commit，删除大文件git filter-branch --force --index-filter &#39;git rm -rf --cached --ignore-unmatch 出错的文件&#39; --prune-empty --tag-name-filter cat -- --all 推送其他文件git push origin master –force 开始上传大文件 下载lfs：git lfs install 文件关联到lfs：git lfs track &quot;filepath&quot; 上述执行完会在目录下看到.gitattributes：git add .gitattributes 之后就可以正常add和commit文件了 push操作 补充： 撤回commit，用git reset –soft HEAD^ 撤销add，git reset HEAD","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"创建环境，使用python打包","slug":"python打包","date":"2020-04-11T09:14:33.000Z","updated":"2020-04-14T03:21:29.271Z","comments":true,"path":"2020/04/11/python打包/","link":"","permalink":"http://yoursite.com/2020/04/11/python打包/","excerpt":"","text":"下载pyinstallerpip install pyinstaller安装 ps: 如果出现下载成功但安装失败，且提示AttributeError: module &#39;enum&#39; has no attribute &#39;IntFlag&#39;尝试直接删除enum包即pip uninstall enum34 下载virtualenvpip install virtualenv安装 使用 创建一个文件夹，并进入到该文件夹下，执行指令virtualenv env为项目安装虚拟环境，会看到目录下有个env文件夹。 激活虚拟环境，env\\Scripts\\activate 用conda安装需要的类库，自己用pip安装库打包总是没加进去类库，不知道为什么 pyinstaller -F filename.py打包，加-F是为了只在dist目录下生成.exe执行文件 ps1: 出现UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 先在命令行执行chcp 65001，再执行打包命令 ps2：如果打包完运行还是找不到库，用--hidden-import=&quot;类库&quot;加上需要的类库打包，比如pyinstaller -F --hidden-import=&quot;类库&quot; filename.py ps3: 遇到打包完运行后出现No module named ‘pkg_resources.py2_warn的问题，用pip install setuptools==44.0.0解决 打包完后，执行.exe出现，No module named ‘tensorflow_core.python 参考博客 其他博客看到的：项目中有tensorflow库时，打包出错，可以尝试一下pip install tensorflow --upgrade --force-reinstall","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"SpringBoot-Web","slug":"SpringBoot-Web","date":"2020-04-06T04:15:15.000Z","updated":"2020-04-06T04:19:41.256Z","comments":true,"path":"2020/04/06/SpringBoot-Web/","link":"","permalink":"http://yoursite.com/2020/04/06/SpringBoot-Web/","excerpt":"","text":"转载的，原地址 Spring Boot Web开发包括json输出，filters，property，log等 JsonSpring Boot只需要类添加 @RestController ，默认类中的方法都会以 json 的格式返回。如果需要使用页面开发只要使用@Controller注解即可，下面会结合模板来说明 Filters使用 filters 用于录调用日志、排除有 XSS 威胁的字符、执行权限验证等等。Spring Boot 自动添加了 OrderedCharacterEncodingFilter 和 HiddenHttpMethodFilter，并且可以自定义 Filter。两个步骤： 实现 Filter 接口，实现 Filter 方法 添加@Configuration 注解，将自定义Filter加入过滤链 12345678910111213141516171819202122232425262728293031323334353637383940@Configurationpublic class WebConfiguration &#123; @Bean public RemoteIpFilter remoteIpFilter() &#123; return new RemoteIpFilter(); &#125; @Bean public FilterRegistrationBean testFilterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter()); registration.addUrlPatterns(\"/*\"); registration.addInitParameter(\"paramName\", \"paramValue\"); registration.setName(\"MyFilter\"); registration.setOrder(1); return registration; &#125; public class MyFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest srequest, ServletResponse sresponse, FilterChain filterChain) throws IOException, ServletException &#123; // TODO Auto-generated method stub HttpServletRequest request = (HttpServletRequest) srequest; System.out.println(\"this is MyFilter,url :\"+request.getRequestURI()); filterChain.doFilter(srequest, sresponse); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125; &#125;&#125; Property自定义配置文件application.properties 12com.eleven.title=Acom.eleven.description=B 自定义配置类 12345678@Componentpublic class NeoProperties &#123; @Value(\"$&#123;com.eleven.title&#125;\") private String title; @Value(\"$&#123;com.eleven.description&#125;\") private String description; //省略getter settet方法&#125; Log配置输出的地址和输出级别 12345# path 为本机的 log 地址，logging.level 后面可以根据包路径配置不同资源的 log 级别logging.path=/user/local/loglogging.level.com.favorites=DEBUGlogging.level.org.springframework.web=INFOlogging.level.org.hibernate=ERROR 数据库操作Jpa 是利用 Hibernate 生成各种自动化的 sql。 1、pom添加相 jar 包 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2、添加配置文件 12345678spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性 其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢 失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 dialect 主要是指定生成表名的存储引擎为 InnoDBDshow-sql 是否打印出自动生成的 SQL，方便调试的时候查看 3、添加实体类和 Dao Entity 中不映射成列的字段得加 @Transient 注解，不加注解也会映射成列 123456789101112131415161718192021@Entitypublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue private Long id; @Column(nullable = false, unique = true) private String userName; @Column(nullable = false) private String passWord; @Column(nullable = false, unique = true) private String email; @Column(nullable = true, unique = true) private String nickName; @Column(nullable = false) private String regTime; //省略getter settet方法、构造方法&#125; Dao 只要继承 JpaRepository 类就可以,可以根据方法名来自动的生成 SQL，比如findByUserName 会自动生成一个以 userName 为参数的查询方法，比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等。 1234public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; User findByUserName(String userName); User findByUserNameOrEmail(String username, String email);&#125; 4、测试 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(Application.class)public class UserRepositoryTests &#123; @Autowired private UserRepository userRepository; @Test public void test() throws Exception &#123; Date date = new Date(); DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG); String formattedDate = dateFormat.format(date); userRepository.save(new User(\"aa1\", \"aa@126.com\", \"aa\", \"aa123456\",formattedDate)); userRepository.save(new User(\"bb2\", \"bb@126.com\", \"bb\", \"bb123456\",formattedDate)); userRepository.save(new User(\"cc3\", \"cc@126.com\", \"cc\", \"cc123456\",formattedDate)); Assert.assertEquals(9, userRepository.findAll().size()); Assert.assertEquals(\"bb\", userRepository.findByUserNameOrEmail(\"bb\", \"cc@126.com\").getNickName()); userRepository.delete(userRepository.findByUserName(\"aa1\")); &#125;&#125; Thymeleaf 模板Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。 12&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;/html&gt; URL Thymeleaf 对于 URL 的处理是通过语法 @{...} 来处理的。Thymeleaf 支持绝对路径 URL： 1&lt;a th:href=\"@&#123;http://www.thymeleaf.org&#125;\"&gt;Thymeleaf&lt;/a&gt; 条件求值 1&lt;a th:href=\"@&#123;/login&#125;\" th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; for循环 12345&lt;tr th:each=\"prod : $&#123;prods&#125;\"&gt; &lt;td th:text=\"$&#123;prod.name&#125;\"&gt;Onions&lt;/td&gt; &lt;td th:text=\"$&#123;prod.price&#125;\"&gt;2.41&lt;/td&gt; &lt;td th:text=\"$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;\"&gt;yes&lt;/td&gt;&lt;/tr&gt; fragment 可以在一个页面中声明模板 123&lt;head th:fragment=\"htmlhead\"&gt; &lt;title th:text=\"$&#123;title&#125;\"&gt;(title)&lt;/title&gt; &lt;/head&gt; 另一个页面应用这个模板 1&lt;head th:include=\"layout :: htmlhead\" th:with=\"title='Hello SpringBoot'\"&gt;&lt;/head&gt; WebJars我们在开发 Java web 项目的时候会使用像 Maven，Gradle 等构建工具以实现对 Jar 包版本依赖管理，以及项目的自动化管理，但是对于 JavaScript，Css 等前端资源包，我们只能采用拷贝到 webapp 下的方式，这样做就无法对这些资源进行依赖管理。那么 WebJars 就提供给我们这些前端资源的 Jar 包形势，我们就可以进行依赖管理。 使用 WebJars - Web Libraries in Jars找对应的组件，比如VueJs 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;vue&lt;/artifactId&gt; &lt;version&gt;2.5.16&lt;/version&gt;&lt;/dependency&gt; 页面引入 1&lt;link th:href=\"@&#123;/webjars/bootstrap/3.3.6/dist/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt;&lt;/link&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Mapreduce","slug":"Mapreduce","date":"2020-04-02T14:32:32.000Z","updated":"2020-04-05T05:30:10.130Z","comments":true,"path":"2020/04/02/Mapreduce/","link":"","permalink":"http://yoursite.com/2020/04/02/Mapreduce/","excerpt":"","text":"MapReduce工作原理 ①Map阶段 将输入的多个分片（Split）由Map任务以完全并行的方式处理。 每个分片由一个Map任务来处理 每个Map任务对输入分片的记录按照一定的规则解析成对 进行文本处理的时候，文本每一行就执行一次Map 由于频繁的磁盘I/O会降低效率，因此Map任务的输出&lt;key,value&gt;对会首先存储在Map任务所在节点的内存缓冲区中 在数据溢写到磁盘之前，会对数据进行分区(Partition)。 • 分区的数量与设置的Reduce任务的数量相同（默认为1，可以在编写MapReduce程序时修改） • 数据分区的划分规则：取&lt;key,value&gt;中对key的hashCode值，然后对Reduce任务数量求余数，余数为分区编号，分区编号相一致的&lt;key,value&gt;则属于同一个分区 • MapReduce提供默认的分区类:HashPartitioner • 分区后，会对同一分区中的&lt;key,value&gt;对按照key进行排序，默认升序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@InterfaceAudience.Public@InterfaceStability.Stablepublic class Mapper&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt; &#123; /** * The &lt;code&gt;Context&lt;/code&gt; passed on to the &#123;@link Mapper&#125; implementations. */ public abstract class Context implements MapContext&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; &#125; /** * Called once at the beginning of the task. */ protected void setup(Context context ) throws IOException, InterruptedException &#123; // NOTHING &#125; /** * Called once for each key/value pair in the input split. Most applications * should override this, but the default is the identity function. */ @SuppressWarnings(\"unchecked\") protected void map(KEYIN key, VALUEIN value, Context context) throws IOException, InterruptedException &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; /** * Called once at the end of the task. */ protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // NOTHING &#125; /** * Expert users can override this method for more complete control over the * execution of the Mapper. * @param context * @throws IOException */ public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; while (context.nextKeyValue()) &#123; map(context.getCurrentKey(), context.getCurrentValue(), context); &#125; &#125; finally &#123; cleanup(context); &#125; &#125;&#125; ②Shuffle阶段将Map任务的无规则输出形成一定的有规则数据，以便Reduce任务进行处理。&lt;key,&lt;1,1,1,1&gt;&gt; ③Reduce阶段 首先对Map阶段的输出结果按照分区进行再一次合并，将同一分区的&lt;key,value&gt;对合并到一起，然后按照key对对分区中的&lt;key,value&gt;对进行排序。 每个分区将排序后的&lt;key,value&gt;对按照key进行分组，key相同的&lt;key,value&gt;对合并为&lt;key,value-list&gt;对，最终每个分区形成多个&lt;key,value-list&gt;对。 排序并分组后的分区数据将会输入到reduce()方法进行处理，reduce()方法一次只能处理一个&lt;key,value-list&gt;对。 最后，reduce()将处理结果仍然以&lt;key,value&gt;对的形式通过context.write(key,value)进行输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Checkpointable@InterfaceAudience.Public@InterfaceStability.Stablepublic class Reducer&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; /** * The &lt;code&gt;Context&lt;/code&gt; passed on to the &#123;@link Reducer&#125; implementations. */ public abstract class Context implements ReduceContext&lt;KEYIN,VALUEIN,KEYOUT,VALUEOUT&gt; &#123; &#125; /** * Called once at the start of the task. */ protected void setup(Context context ) throws IOException, InterruptedException &#123; // NOTHING &#125; /** * This method is called once for each key. Most applications will define * their reduce class by overriding this method. The default implementation * is an identity function. */ @SuppressWarnings(\"unchecked\") protected void reduce(KEYIN key, Iterable&lt;VALUEIN&gt; values, Context context ) throws IOException, InterruptedException &#123; for(VALUEIN value: values) &#123; context.write((KEYOUT) key, (VALUEOUT) value); &#125; &#125; /** * Called once at the end of the task. */ protected void cleanup(Context context ) throws IOException, InterruptedException &#123; // NOTHING &#125; /** * Advanced application writers can use the * &#123;@link #run(org.apache.hadoop.mapreduce.Reducer.Context)&#125; method to * control how the reduce task works. */ public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; while (context.nextKey()) &#123; reduce(context.getCurrentKey(), context.getValues(), context); // If a back up store is used, reset it Iterator&lt;VALUEIN&gt; iter = context.getValues().iterator(); if(iter instanceof ReduceContext.ValueIterator) &#123; ((ReduceContext.ValueIterator&lt;VALUEIN&gt;)iter).resetBackupStore(); &#125; &#125; &#125; finally &#123; cleanup(context); &#125; &#125;&#125; MapReduce实例应用单词计数Map类12345678910public class WordCountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; public void map(LongWritable key,Text value,Context context) throws IOException,InterruptedException&#123; //1.数据类型转换和以空格切分单词 String[] line=value.toString().split(\" \"); //2.循环遍历单词 for(String word:line) //3.输出结果 context.write(new Text(word), new IntWritable(1)); &#125;&#125; Reduce类1234567891011public class WordCountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123; public void reduce(Text key,Iterable&lt;IntWritable&gt; values,Context context) throws IOException,InterruptedException&#123; int sum=0; //1.循环遍历迭代器,累加相同结果 for(IntWritable v:values) sum += v.get(); //2.输出结果 context.write(key, new IntWritable(sum)); &#125;&#125; Job类123456789101112131415161718192021222324252627282930313233343536public class WordCount &#123; public static void main( String[] args ) throws Exception&#123; Configuration conf =new Configuration(); //新建Job Job job = Job.getInstance(conf,WordCount.class.getName()); job.setJarByClass(WordCount.class); //设置Mapper、Reducer job.setMapperClass(WordCountMapper.class); job.setReducerClass(WordCountReducer.class); //设置Map输出类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); //设置Reduce输出类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); //job.setCombinerClass(WordCountReducer.class); //设置输入输出格式 job.setInputFormatClass(TextInputFormat.class); job.setOutputFormatClass(TextOutputFormat.class); //设置输入输出路径 FileInputFormat.addInputPath(job, new Path(args[0]+\"/input\")); FileOutputFormat.setOutputPath(job, new Path(args[0]+\"/output\")); //提交作业 job.waitForCompletion(true); &#125;&#125; 去重Map类12345public class UniqueMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt;&#123; public void map(LongWritable key,Text value,Context context) throws IOException,InterruptedException&#123; context.write(value, new Text()); &#125;&#125; Reduce类12345public class UniqueReducer extends Reducer&lt;Text, Text, Text, Text&gt;&#123; public void reduce(Text key,Iterable&lt;Text&gt; values,Context context) throws IOException,InterruptedException&#123; context.write(key, new Text()); &#125;&#125; 去重计数Map类12345678public class UserCountMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt;&#123; public void map(LongWritable key,Text value,Context context) throws IOException,InterruptedException&#123; //数据类型转换和以制表符切分单词 String[] line=value.toString().split(\"\\t\"); //key: 用户ID value：因为不需要map的value做计算，随便赋值即可 context.write(new Text(line[1]),new Text()); &#125; &#125; Reduce类12345678public class UserCountReducer extends Reducer&lt;Text, Text, Text, Text&gt;&#123; //No：计数器 private static int No = 1; public void reduce(Text key,Iterable&lt;Text&gt; values,Context context) throws IOException,InterruptedException&#123; context.write(new Text(String.valueOf(No)),key); No++; &#125;&#125; 二次排序自定义map的key类型1234567891011121314151617181920212223242526272829303132public class SecondarySortKeyPair implements WritableComparable&lt;SecondarySortKeyPair&gt;&#123; private String first; private int second; public void readFields(DataInput input)throws IOException&#123; this.first = input.readUTF(); this.second = input.readInt(); &#125; public void write(DataOutput output)throws IOException&#123; output.writeUTF(first); output.writeInt(second); &#125; public int compareTo(SecondarySortKeyPair k) &#123; int res = this.first.compareTo(k.getFirst()); if(res!=0) return res; else return -Integer.valueOf(this.second).compareTo(Integer.valueOf(k.getSecond())); &#125; public String getFirst() &#123; return first; &#125; public void setFirst(String first) &#123; this.first=first; &#125; public int getSecond() &#123; return second; &#125; public void setSecond(int second) &#123; this.second=second; &#125;&#125; 排序123456789public class SecondarySortReducer extends Reducer&lt;SecondarySortKeyPair, IntWritable, Text, IntWritable&gt;&#123; public void reduce(SecondarySortKeyPair key,Iterable&lt;IntWritable&gt; values,Reducer&lt;SecondarySortKeyPair,IntWritable,Text,IntWritable&gt;.Context context) throws IOException,InterruptedException&#123; Text outKey=new Text(); for(IntWritable v:values) &#123; outKey.set(key.getFirst()); context.write(outKey, v); &#125; &#125;&#125; 分区12345public class SecondarySortPartitioner extends Partitioner&lt;SecondarySortKeyPair,IntWritable&gt;&#123; public int getPartition(SecondarySortKeyPair keyPair,IntWritable vaule,int numPartitions) &#123; return (keyPair.getFirst().hashCode()&amp;Integer.MAX_VALUE)%numPartitions; &#125;&#125; Map类123456789101112public class SecondarySortMapper extends Mapper&lt;LongWritable, Text, SecondarySortKeyPair, IntWritable&gt;&#123; public void map(LongWritable key,Text value,Mapper&lt;LongWritable,Text,SecondarySortKeyPair,IntWritable&gt;.Context context) throws IOException,InterruptedException&#123; String line=value.toString(); String[] ss=line.split(\"\\t\"); SecondarySortKeyPair outKey=new SecondarySortKeyPair(); outKey.setFirst(ss[0]); outKey.setSecond(Integer.valueOf(ss[1])); IntWritable outValue=new IntWritable(); outValue.set(Integer.valueOf(ss[1])); context.write(outKey, outValue); &#125;&#125; Reduce类123456789public class SecondarySortReducer extends Reducer&lt;SecondarySortKeyPair, IntWritable, Text, IntWritable&gt;&#123; public void reduce(SecondarySortKeyPair key,Iterable&lt;IntWritable&gt; values,Reducer&lt;SecondarySortKeyPair,IntWritable,Text,IntWritable&gt;.Context context) throws IOException,InterruptedException&#123; Text outKey=new Text(); for(IntWritable v:values) &#123; outKey.set(key.getFirst()); context.write(outKey, v); &#125; &#125;&#125; Job类1234567891011121314151617181920212223242526272829Configuration conf =new Configuration(); //新建JobJob job = Job.getInstance(conf,unique.class.getName());job.setJarByClass(unique.class);//设置Mapper、Map输出类型job.setMapperClass(SecondarySortMapper.class);job.setPartitionerClass(SecondarySortPartitioner.class);job.setGroupingComparatorClass(SecondarySortGroupComparator.class);job.setReducerClass(SecondarySortReducer.class);job.setMapOutputKeyClass(SecondarySortKeyPair.class);job.setMapOutputValueClass(IntWritable.class); //设置Reduce输出类型job.setOutputKeyClass(Text.class);job.setOutputValueClass(IntWritable.class); job.setInputFormatClass(TextInputFormat.class);job.setOutputFormatClass(TextOutputFormat.class);//输入第一个文件路径FileInputFormat.addInputPath(job, new Path(args[0]+\"/input\")); FileOutputFormat.setOutputPath(job, new Path(args[1]+\"output\"));//提交作业job.waitForCompletion(true); 利用cleanup处理复杂的应用任务要求：对有39列的汽车销售记录进行处理，得到每月每种车型的销售总量，以及每月的销售总量，并对其进行二次排序输出。 思路：分成两个mapreduce来完成，第一个mapreduce用来统计每月每种品牌的销量，并对每月的销量进行统计，第二个mapreduce将一个mapreduce的结果进行二次排序。 第一个Map类123456789101112131415161718public class MonthCarMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; public void map(LongWritable key,Text value,Context context) throws IOException,InterruptedException&#123; //以逗号切分 String[] line=value.toString().split(\",\"); //首先判断列数是否为39 if(line.length == 39) &#123; //月份 String month = line[1]; //品牌 String car = line[7]; //判断所需要的属性是否为空值 if(car.length()!=0 &amp;&amp; month.length()!=0) &#123; //写入 context.write(new Text(month + \",\" + car), new IntWritable(1)); &#125; &#125; &#125;&#125; 第一个Reduce类1234567891011121314151617181920212223242526272829303132public class MonthCarReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123; //存放reduce后的每个结果 HashMap&lt;String,Integer&gt; hashmap = new HashMap&lt;String,Integer&gt;(); //存放车型结果，key：月份，value：销售数量 HashMap&lt;String,Integer&gt; hashmapMonth = new HashMap&lt;String,Integer&gt;(); public void reduce(Text key,Iterable&lt;IntWritable&gt; values,Context context) throws IOException,InterruptedException&#123; int sum = 0; //循环遍历迭代器,累加相同结果 for(IntWritable v:values) sum += v.get(); //写入hashmap hashmap.put(key.toString(), sum); //输出结果 context.write(key, new IntWritable(sum)); &#125; public void cleanup(Context context) throws IOException,InterruptedException &#123; //对hashmap的每条记录进行遍历，将hashmap的key进行分割得到月份（k[0]），统计放入hashmapMonth for(String key:hashmap.keySet())&#123; String[] k=key.split(\",\"); if(hashmapMonth.containsKey(k[0])) &#123; hashmapMonth.put(k[0], hashmapMonth.get(k[0]) + hashmap.get(key)); &#125;else &#123; hashmapMonth.put(k[0], hashmap.get(key)); &#125; &#125; //输出月份的小计 for(String month:hashmapMonth.keySet()) &#123; context.write(new Text(month+\",小计\"), new IntWritable(hashmapMonth.get(month))); &#125; &#125; &#125; 第二个Map类（需要利用二次排序中自定义的类）123456789101112public class SecondarySortMapper extends Mapper&lt;LongWritable, Text, SecondarySortKeyPair, Text&gt;&#123; public void map(LongWritable key,Text value,Mapper&lt;LongWritable,Text,SecondarySortKeyPair,Text&gt;.Context context) throws IOException,InterruptedException&#123; String[] ss=value.toString().split(\",\"); SecondarySortKeyPair outKey=new SecondarySortKeyPair(); outKey.setFirst(Integer.valueOf(ss[0])); //ss[0]为月份 outKey.setSecond(Integer.valueOf(ss[2])); //ss[2]为销量 context.write(outKey, new Text(ss[1])); //key:月份，销量 value:品牌 &#125; &#125; 第二个Reduce类12345678910111213141516171819public class SecondarySortReducer extends Reducer&lt;SecondarySortKeyPair, Text, Text, Text&gt;&#123; public void reduce(SecondarySortKeyPair key,Iterable&lt;Text&gt; values,Reducer&lt;SecondarySortKeyPair,Text,Text,Text&gt;.Context context) throws IOException,InterruptedException&#123; Text outKey=new Text(); for(Text v:values) &#123; //月份 String month = String.valueOf(key.getFirst()); //销量 String num = String.valueOf(key.getSecond()); //品牌 String car = v.toString(); //按规定输出 if(month.length() == 2) context.write(new Text(month + \",\" + car), new Text(num)); else//给一位数的月份补0 context.write(new Text(\"0\" + month + \",\" + car), new Text(num)); &#125; &#125;&#125; Job12345Configuration conf =new Configuration(); //设置输出key和value之间的连接符conf.set(\"mapred.textoutputformat.separator\", \",\"); //设置排序的比较器job2.setGroupingComparatorClass(SecondarySortGroupComparator.class);","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"}],"tags":[]},{"title":"SpringBoot属性配置文件","slug":"SpringBoot属性配置文件","date":"2020-03-31T15:43:00.000Z","updated":"2020-03-31T16:58:19.511Z","comments":true,"path":"2020/03/31/SpringBoot属性配置文件/","link":"","permalink":"http://yoursite.com/2020/03/31/SpringBoot属性配置文件/","excerpt":"","text":"自定义属性与加载","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"keras搭建（Windows）","slug":"keras搭建","date":"2020-03-27T04:07:05.000Z","updated":"2020-03-27T04:11:50.856Z","comments":true,"path":"2020/03/27/keras搭建/","link":"","permalink":"http://yoursite.com/2020/03/27/keras搭建/","excerpt":"","text":"安装教程1234567891011121314151617cmd中输入# GPU 版本pip install --upgrade tensorflow-gpu # CPU 版本pip install --upgrade tensorflow # Keras 安装pip install keras -U --pre#检测是否完成import keras &gt;&gt;&gt; conda install git&gt;&gt;&gt; git clone https://github.com/fchollet/keras.git&gt;&gt;&gt; cd keras/examples/&gt;&gt;&gt; python mnist_mlp.py#成功运行则keras安装完成","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[]},{"title":"Win10能连上热点但连路由器上不了网解决方案","slug":"Win10能连上热点但连路由器上不了网解决方案","date":"2020-03-22T04:24:15.000Z","updated":"2020-03-22T04:31:48.437Z","comments":true,"path":"2020/03/22/Win10能连上热点但连路由器上不了网解决方案/","link":"","permalink":"http://yoursite.com/2020/03/22/Win10能连上热点但连路由器上不了网解决方案/","excerpt":"","text":"忽然就发现电脑连接路由器wifi上不了网，但连接热点就可以，还专门下载了电脑管家但是没能解决问题。最终百度发现一个可行的办法。管理员模式打开cmd，输入命令netsh winsock reset catalog netsh int ip reset reset.log重启电脑应该就可以了。","categories":[{"name":"Win10","slug":"Win10","permalink":"http://yoursite.com/categories/Win10/"}],"tags":[]},{"title":"RSA密码算法步骤","slug":"RSA密码算法步骤","date":"2020-03-17T12:36:47.000Z","updated":"2020-03-17T13:01:00.254Z","comments":true,"path":"2020/03/17/RSA密码算法步骤/","link":"","permalink":"http://yoursite.com/2020/03/17/RSA密码算法步骤/","excerpt":"","text":"生成密钥对 随机找两个质数 P 和 Q ,P 与 Q 越大，越安全。 计算n=p*q 计算 n 的欧拉函数 φ(n)=(p-1)*(q-1) 随机选择一个整数 e，条件是1&lt; e &lt; φ(n)，且 e 与 m 互质。 算出一个整数 d，可以使得 (e*d)%φ(n)=1，也就是ex-φ(n)y=1，使用扩展欧几里得算法。 def ext_euclid(a, b): old_s,s=1,0 old_t,t=0,1 old_r,r=a,b if b == 0: return 1, 0, a else: while(r!=0): q=old_r//r old_r,r=r,old_r-q*r old_s,s=s,old_s-q*s old_t,t=t,old_t-q*t return old_s, old_t, old_r if __name__ == &apos;__main__&apos;: print(ext_euclid(e,φ(n)))这时候公钥是(e,n)，私钥是(d,n) 对明文分组对明文转化为二进制分组，使得每组必须小于n。 加密 c=m^e%n 解密 m=c^d%n 加密和解密用快速取模指数算法def fastExpMod(b, e, m): result = 1 while e != 0: if (e&amp;1) == 1: # ei = 1, then mul result = (result * b) % m e &gt;&gt;= 1 # b, b^2, b^4, b^8, ... , b^(2^n) b = (b*b) % m return result if __name__ == &apos;__main__&apos;: print(fastExpMod(m, e, n)) print(fastExpMod(c, d, n))例子p=17,q=19,n=pq=323,φ(n)=1618=288,e=101,d=77。明文0224010417,分组，使得每组必须小于n,得两位为一组。m1=02,m2=24,m3=01,m4=04,m5=17.之后加密解密即可验证正确性。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/categories/网络安全/"}],"tags":[]},{"title":"Android-Studio-新建一个项目","slug":"Android-Studio-新建一个项目","date":"2020-03-15T02:37:22.000Z","updated":"2020-04-08T02:37:01.291Z","comments":true,"path":"2020/03/15/Android-Studio-新建一个项目/","link":"","permalink":"http://yoursite.com/2020/03/15/Android-Studio-新建一个项目/","excerpt":"","text":"建立一个项目 点击新建一个工程 选择No Activity下一步 自行修改项目名称后Finish 右键Java下的文件，新建一个Empty的Activity 填写Configure Activity，可以选择Generate a Layout File，这里演示不选择的情况 右键res，新建一个文件夹，命名为layout 右键layout文件夹，新建一个Layout Resource File，为layout命名 编写layout文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#E6E6E6\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"70dp\" android:layout_height=\"70dp\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"40dp\" app:srcCompat=\"@drawable/i\" /&gt; &lt;LinearLayout android:id=\"@+id/first_liner\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/imageView\" android:layout_centerVertical=\"true\" android:layout_marginBottom=\"5dp\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_marginTop=\"15dp\"&gt; &lt;TextView android:id=\"@+id/textView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:padding=\"10dp\" android:text=\"账号：\" android:textColor=\"#000\" android:textSize=\"20sp\" /&gt; &lt;EditText android:id=\"@+id/editText1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_toRightOf=\"@id/textView1\" android:background=\"@null\" android:padding=\"10dp\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/second_liner\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/first_liner\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\"&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:padding=\"10dp\" android:text=\"密码：\" android:textColor=\"#000\" android:textSize=\"20sp\" /&gt; &lt;EditText android:id=\"@+id/editText2\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"5dp\" android:layout_toRightOf=\"@id/textView2\" android:background=\"@null\" android:inputType=\"textPassword\" android:padding=\"10dp\"/&gt; &lt;/LinearLayout&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/second_liner\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_marginTop=\"50dp\" android:background=\"#3C8Dc4\" android:text=\"登录\" android:textColor=\"#ffffff\" android:textSize=\"20sp\"/&gt;&lt;/RelativeLayout&gt; 启动 java文件中onCreate补充代码如下： 1setContentView(R.layout.login_layout); 补充AndroidManifest.xml中代码: 123456&lt;activity android:name=\".QQ登录\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 启动模拟器（在主页长按鼠标往上拉可以找到应用） ​","categories":[{"name":"Android-Studio","slug":"Android-Studio","permalink":"http://yoursite.com/categories/Android-Studio/"}],"tags":[]},{"title":"二叉树","slug":"二叉树","date":"2020-03-10T13:25:45.000Z","updated":"2020-03-10T13:26:27.720Z","comments":true,"path":"2020/03/10/二叉树/","link":"","permalink":"http://yoursite.com/2020/03/10/二叉树/","excerpt":"","text":"层次遍历-BFS递归class Solution { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public void helped(TreeNode root,int level){ if(res.size() == level) res.add(new ArrayList&lt;Integer&gt;()); res.get(level).add(root.val); if(root.left != null){ helped(root.left, level+1); } if(root.right != null){ helped(root.right, level+1); } } public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root == null) return res; helped(root,0); return res; } }迭代class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root){ List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int level = 0; while(!queue.isEmpty()){ res.add(new ArrayList&lt;Integer&gt;()); int length = queue.size(); for(int i=0;i&lt;length;i++){ TreeNode r=queue.remove(); res.get(level).add(r.val); if(r.left != null) queue.add(r.left); if(r.right != null) queue.add(r.right); } level++; } return res; } }前序遍历递归class Solution { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { middle(root); return res; } public void middle(TreeNode root){ if(root==null) return; res.add(root.val); middle(root.left); middle(root.right); } }迭代class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; s=new Stack&lt;TreeNode&gt;(); while(root!=null || !s.isEmpty()){ while(root!=null){ res.add(root.val); s.push(root); root=root.left; } TreeNode pop=s.pop(); root=pop.right; } return res; } }中序遍历递归class Solution { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { middle(root); return res; } public void middle(TreeNode root){ if(root==null) return; middle(root.left); res.add(root.val); middle(root.right); } }迭代class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); while(root != null || !s.isEmpty()){ while(root != null){ s.push(root); root = root.left; } root = s.pop(); res.add(root.val); root = root.right; } return res; } }后序遍历递归class Solution { List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { after(root); return res; } public void after(TreeNode root) { if(root==null) return; after(root.left); after(root.right); res.add(root.val); } }迭代class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; s=new Stack&lt;TreeNode&gt;(); TreeNode cur=root; TreeNode last=null; while(cur!=null || !s.isEmpty()){ while(cur!=null){ s.push(cur); cur=cur.left; } cur=s.peek(); if(cur.right==null || cur.right==last){ res.add(cur.val); s.pop(); last=cur; cur=null; }else{ cur=cur.right; } } return res; } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"HashMap","slug":"HashMap","date":"2020-03-07T14:57:21.000Z","updated":"2020-03-08T07:39:09.142Z","comments":true,"path":"2020/03/07/HashMap/","link":"","permalink":"http://yoursite.com/2020/03/07/HashMap/","excerpt":"","text":"HashMa简介HashMap继承了Map接口,主要用来存放键值对。JDK1.8 之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。 定义HashMap的数据是存在table数组中的，它是一个Entry数组,JDK8中取名为Node，Entry是HashMap的一个静态内部类。 /** * Node = HashMap的内部类，实现了Map.Entry接口，本质是键值对 * 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法 **/ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; // 哈希值，HashMap根据该值确定记录的位置 final K key; // key V value; // value Node&lt;K,V&gt; next;// 链表下一个节点 // 构造方法 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } // 返回 与 此项 对应的键 public final K getKey() { return key; } // 返回 与 此项 对应的值 public final V getValue(){ return value; } public final String toString() { return key + &quot;=&quot; + value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } /** * hashCode（） */ public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } /** * equals（） * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true */ public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } }参数 /** * 主要参数 同 JDK 1.7 * 即：容量、加载因子、扩容阈值（要求、范围均相同） */ // 1. 容量（capacity）： 必须是2的幂 &amp; &lt;最大容量（2的30次方） // 默认容量=16=1&lt;&lt;4=00001中的1向左移4位=10000=十进制的2^4=16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量=2的30次方（若传入的容量过大，将被最大值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 2. 加载因子(Load factor)：HashMap在其容量达到某个范围会自动增加 final float loadFactor; // 实际加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认加载因子= 0.75 // 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） // a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数 // b. 扩容阈值 = 容量 x 加载因子 int threshold; // 4. 其他 transient Node&lt;K,V&gt;[] table; // 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表 transient int size;// HashMap的大小，即 HashMap中存储的键值对的数量 /** * 与红黑树相关的参数 */ // 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树 static final int TREEIFY_THRESHOLD = 8; // 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表 static final int UNTREEIFY_THRESHOLD = 6; // 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许将链表 转换成红黑树 // 否则，若桶内元素太多时，则直接扩容，而不是树形化 // 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD static final int MIN_TREEIFY_CAPACITY = 64; initialCapacity是HashMap的初始化容量(即初始化table时用到)，默认为16。 loadFactor为加载因子，默认为0.75。 加载因子过小会导致空间利用率低，频繁扩容也会消耗性能； 加载因子过大会导致哈希冲突概率变大，链表变长，查找效率低。 threshold是HashMap进行扩容的阀值，当HashMap的存放的元素个数超过该值时，会进行扩容，它的值为HashMap的容量乘以负载因子。比如，HashMap的默认阀值为16*0.75，即12。 构造方法/** * 函数使用原型 */ Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); /** * 源码分析：主要是HashMap的构造函数 = 4个 * 仅贴出关于HashMap构造函数的源码 */ public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable{ // 省略上节阐述的参数 /** * 构造函数1：默认构造函数（无参） * 加载因子 &amp; 容量 = 默认 = 0.75、16 */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } /** * 构造函数2：指定“容量大小”的构造函数 * 加载因子 = 默认 = 0.75 、容量 = 指定大小 */ public HashMap(int initialCapacity) { // 实际上是调用指定“容量大小”和“加载因子”的构造函数 // 只是在传入的加载因子参数 = 默认加载因子 this(initialCapacity, DEFAULT_LOAD_FACTOR); } /** * 构造函数3：指定“容量大小”和“加载因子”的构造函数 * 加载因子 &amp; 容量 = 自己指定 */ public HashMap(int initialCapacity, float loadFactor) { // 指定初始容量必须非负，否则报错 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 &gt; 最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 填充比必须为正 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // 设置 加载因子 this.loadFactor = loadFactor; // 设置 扩容阈值 // 注：此处不是真正的阈值，仅仅只是将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂，该阈值后面会重新计算 // 下面会详细讲解 -&gt;&gt; 分析1 this.threshold = tableSizeFor(initialCapacity); } /** * 构造函数4：包含“子Map”的构造函数 * 即 构造出来的HashMap包含传入Map的映射关系 * 加载因子 &amp; 容量 = 默认 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) { // 设置容量大小 &amp; 加载因子 = 默认 this.loadFactor = DEFAULT_LOAD_FACTOR; // 将传入的子Map中的全部元素逐个添加到HashMap中 putMapEntries(m, false); } } /** * 分析1：tableSizeFor(initialCapacity) * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂 * 与JDK 1.7对比：类似于JDK 1.7 中 inflateTable()里的 roundUpToPowerOf2(toSize) */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }红黑树节点实现类/** * 红黑树节点 实现类：继承自LinkedHashMap.Entry&lt;K,V&gt;类 */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { // 属性 = 父节点、左子树、右子树、删除辅助节点 + 颜色 TreeNode&lt;K,V&gt; parent; TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; boolean red; // 构造函数 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } // 返回当前节点的根节点 final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } } hash()函数 // JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动） // 1. 取hashCode值： h = key.hashCode()，hashCode()来自object方法。 // 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16) static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // a. 当key = null时，hash值 = 0，所以HashMap的key 可为null // 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null // b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制 }indexFor()函数static int indexFor(int h, int length) { return h &amp; (length-1); }length为什么是偶数？length为HashMap的当前长度，首先看如何根据key值来找数组的下标，它是用key的哈希值 &amp; (length-1);说法一：length是2的幂次方，所以一定是偶数，length-1为奇数，那么可以保证最低位为1，与hash值做与运算，代替求余运算提高性能，结果就取决于哈希值，所以在任何一个位置上都有可以被存放，减小哈希碰撞。说法二：如果数组长度的二进制是0的话，key的hashcode值的每一位无论是1还是0做与运算都是0，这样重复的概率就变大，因此必须都是1，而2^N - 1可以使二进制每位都是1。所以2的幂次方是为了①减少哈希碰撞 ②可以使用&amp;运算来提高效率 put()函数/** * 分析2：putVal(hash(key), key, value, false, true) */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 1. 若哈希表的数组table为空，则 通过resize() 创建 // 所以，初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 2. 计算插入存储的数组索引i：根据键值key计算的hash值 得到 // 此处的数组下标计算方式 = i = (n - 1) &amp; hash // 3. 插入时，需判断是否存在Hash冲突： // 若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕 // 否则，代表存在Hash冲突，即当前存储位置已存在节点，则依次往下判断：a. 当前位置的key是否与需插入的key相同、b. 判断需插入的数据结构是否为红黑树 or 链表 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //new Node&lt;&gt;(hash, key, value, next) else { Node&lt;K,V&gt; e; K k; // a. 判断 table[i]的元素的key是否与 需插入的key一样，若相同则 直接用新value 覆盖 旧value // 判断原则：equals（） if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // b. 继续判断：需插入的数据结构是否为红黑树 or 链表 // 若是红黑树，则直接在树中插入 or 更新键值对 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); -&gt;&gt;分析3 // 若是链表,则在链表中插入 or 更新键值对 // i. 遍历table[i]，判断Key是否已存在：采用equals（） 对比当前遍历节点的key 与 需插入数据的key：若已存在，则直接用新value 覆盖 旧value // ii. 遍历完毕后仍无发现上述情况，则直接在链表尾部插入数据 // 注：新增节点后，需判断链表长度是否&gt;8（8 = 桶的树化阈值）：若是，则把链表转换为红黑树 else { for (int binCount = 0; ; ++binCount) { // 对于ii：若数组的下1个位置，表示已到表尾也没有找到key值相同节点，则新建节点 = 插入节点 // 注：此处是从链表尾插入，与JDK 1.7不同（从链表头插入，即永远都是添加到数组的位置，原来数组位置的数据则往后移） if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 插入节点后，若链表节点&gt;数阈值，则将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); // 树化操作 break; } // 对于i if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 更新p指向下一个节点，继续遍历 p = e; } } // 对i情况的后续操作：发现key已存在，直接用新value 覆盖 旧value &amp; 返回旧value if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 替换旧值时会调用的方法（默认实现为空） return oldValue; } } ++modCount; // 插入成功后，判断实际存在的键值对数量size &gt; 最大容量threshold // 若 &gt; ，则进行扩容 -&gt;&gt;分析4（但单独讲解，请直接跳出该代码块） if (++size &gt; threshold) resize(); afterNodeInsertion(evict);// 插入成功时会调用的方法（默认实现为空） return null; } /** * 分析3：putTreeVal(this, tab, hash, key, value) * 作用：向红黑树插入 or 更新数据（键值对） * 过程：遍历红黑树判断该节点的key是否与需插入的key 相同： * a. 若相同，则新value覆盖旧value * b. 若不相同，则插入 */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp;(q = ch.find(h, k, kc)) != null) ||((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; } } }put的流程: 先用key算hash值，然后取模，求位置 如果该位置没存放值那么就直接存放， 有的话，看是链表还是红黑树，如果是红黑树，遍历树看是否有一样的key，如果有就旧值覆盖新值，没有就插入到树中。如果是链表，遍历链表，是否有一样的key，如果有就旧值覆盖新值，没有就插入到链表尾部，然后看看是否需要转化为红黑树和是否需要扩容。 key为null,存放在下标为0的位置。（取值为null） 关于需要同时比较hash值和key有以下两点需要注意 为什么比较了hash值还需要比较key：因为不同对象的hash值可能一样 为什么不只比较equal：因为equal可能被重写了，重写后的equal的效率要低于hash的直接比较 resize()函数 若当前容量 &gt; 最大值，则不扩容。 否则，根据2倍当前容量来新建数组，保存旧数组数据，遍历旧数组上每个数据，重新计算每个数据在新数组上的位置，一个一个插入。然后将新数组引用到HashMap的table属性上。重新设置扩容阀值。HashMap扩容的阀值，值为HashMap的当前容量 * 负载因子，默认为12 = 16 * 0.75 get()函数计算要获取数据的hash值，得到存放在数组的位置，依次在该位置、红黑树、链表上寻找。 /** * 函数原型 * 作用：根据键key，向HashMap获取对应的值 */ map.get(key)； /** * 源码分析 */ public V get(Object key) { Node&lt;K,V&gt; e; // 1. 计算需获取数据的hash值 // 2. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1 // 3. 获取后，判断数据是否为空 return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * 分析1：getNode(hash(key), key)) */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 1. 计算存放在数组table中的位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断） // a. 先在数组中找，若存在，则直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // b. 若数组中没有，则到红黑树中寻找 if ((e = first.next) != null) { // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // c. 若红黑树中也没有，则通过遍历，到链表中寻找 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; }线程不安全此时若（多线程）并发执行 put()操作，一旦出现扩容情况，则容易出现环形链表，从而在获取数据、遍历链表时形成死循环，即 死锁的状态。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"centos无法上网的问题","slug":"centos无法上网的问题","date":"2020-03-07T13:17:30.000Z","updated":"2020-04-08T15:09:42.876Z","comments":true,"path":"2020/03/07/centos无法上网的问题/","link":"","permalink":"http://yoursite.com/2020/03/07/centos无法上网的问题/","excerpt":"","text":"设置VM虚拟网络在VMware中的菜单栏【编辑】-【虚拟网络编辑器】，在窗口中将外部网络设置为【NAT模式】，并修改子网IP、网关IP（子网IP：192.168.170.0，网关IP：192.168.170.2），记录子网掩码，DNS。 配置静态IP地址执行命令：sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33修改如下： BOOTPROTO=static DEFROUTE=yes .... IPADDR=192.168.170.133 #ip地址 NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.170.2 #网关IP DNS=192.168.170.2 #DNS设置路由 sudo vim /etc/resolv.conf –添加DNS #Generated by NetworkManager nameserver 192.168.170.2 search localdomain sudo vi /etc/sysconfig/network-scripts/route-ens33添加永久静态路由 192.168.170.0/24 via 192.168.170.2 #DNS 0.0.0.0/0 via 192.168.170.2 #DNS /etc/sysconfig/static-routes查看是否有路由文件，没有则echo创建 any net 192.168.170.0 netmask 255.255.255.0 gw 192.168.170.2 #内网路由 any net 0.0.0.0 netmask 0.0.0.0 gw 192.168.170.2 #默认路由 重启service network restart–重启网卡 reboot–重启 PS：若是重启网卡失败，并按照systemctl status network.service提示查看，有提示红色错误Failed to start LSB: Bring up/down networking.,则 用ip addr查看mac地址，在第二项link/ether mac地址 brd ff:ff:ff:ff:ff:ff sudo vim /etc/sysconfig/network-scripts/ifcfg-eth0添加 HWADDR=mac地址比如HWADDR=00:0c:29:fa:d3:07 service network restart–重启网卡","categories":[{"name":"centos","slug":"centos","permalink":"http://yoursite.com/categories/centos/"}],"tags":[]},{"title":"java-设计模式之单例模式","slug":"java-设计模式之单例模式","date":"2020-03-01T11:51:43.000Z","updated":"2020-03-05T05:29:58.655Z","comments":true,"path":"2020/03/01/java-设计模式之单例模式/","link":"","permalink":"http://yoursite.com/2020/03/01/java-设计模式之单例模式/","excerpt":"","text":"单例模式是指整个程序中仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。 单例模式，一般用于比较复杂的对象，只初始化一次，其构造函数是被private修饰，使得外面调用不到构造函数，从而不能new出一个实例，只能通过调用getInstance方法来得到对象，且getInstance函数保证每次调用都返回相同的对象。 饿汉模式类对象一开始就初始化，不管需不需要，都会创建。因为一开始就创建好实例，所以是线程安全的。 public class SingleHungry{ private static SingleHungry sh=new SingleHungry(); private SingleHungry{ } public static SingleHungry getInstance(){ return sh; } }懒汉模式对象初始化被放到了实例化方法中，延迟实例化，但是当多个线程统一访问时，有可能出现线程不安全的情况，需要优化。 public class SingleLazy{ private static SingleLazy sh=null; private SingleLazy{ } public static SingleLazy getInstance(){ if(sh==null) sh=new SingleLazy(); return sh; } }双重检测双重校验锁式分别在锁的前后进行判空校验，双重校验锁式是线程安全的。加上volatile关键字修饰变量来达到稳定效果。 public class SingleLazy{ private volatile static SingleLazy sh=null; private SingleLazy{ } public static SingleLazy getInstance(){ if(sh == null){ synchronized(SingleLazy.class){ if(sh == null){ sh = new SingleLazy(); } } } return sh; } }静态内部类静态内部类即使类被加载也不会创建单例对象，除非调用getInstance()，只有当调用getInstance()方法，才会被装载SingleInnerHolder类，从而实例化单例对象。 public class SingleInner{ private static class SingleInnerHolder{ private static SingleInner instance = new SingleInner(); } private SingleInner{ } public static SingleInner getInstance(){ return SingleInnerHolder.instance; } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java-反射","slug":"Java反射","date":"2020-02-25T13:14:03.000Z","updated":"2020-03-05T05:39:06.812Z","comments":true,"path":"2020/02/25/Java反射/","link":"","permalink":"http://yoursite.com/2020/02/25/Java反射/","excerpt":"","text":"反射：框架设计的灵魂框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。反射：java反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，修改它的任意属性；这种动态获取的信息以及动态调用对象成员的功能称为反射机制。好处：①可以在程序运行过程中，操作这些对象 ②可以解耦，提高程序的可扩展性 Java代码经历的三阶段：Source源代码阶段——&gt;Class类对象阶段——&gt;Runtime运行时阶段 获取Class对象的方法：1.Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义咋配置文件中。读取文件，加载类2.类名.class：通过类名的属性class获取 * 多用于参数的传递3.对象.getClass():getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 结论： 同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方法获取的Class对象都是同一个。 Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名注解用来做标注用：可以在类、字段变量、方法、接口等位置进行一个特殊的标记，为后续做一些诸如：代码生成、数据校验、资源整合等工作做铺垫。注解一旦对代码标注完成，后续我们就可以结合Java强大的反射机制，在运行时动态地获取到注解的标注信息，从而可以执行很多其他逻辑，完成我们想要的自动化工作。 写一个@Length注解第一步：首先定义注解：@Length@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface Length{ int min();// 允许字符串长度的最小值 int max();// 允许字符串长度的最大值 int errogrMsg();// 自定义的错误提示信息 }下面做几点说明：1、注解的定义有点像定义接口 interface，但唯一不同的是前面需要加一个@符号2、注解的成员变量只能使用基本类型、 String或者 enum枚举，比如 int可以，但 Integer这种包装类型就不行，需注意3、像上面 @Target、 @Retention这种加在注解定义上面的注解，我们称为 “元注解”，元注解就是专门用于给注解添加注解的注解，哈哈，很拗口，简单理解，元注解就是天生就有的注解，可直接用于注解的定义上4、 @Target(xxx) 用来说明该自定义注解可以用在什么位置，比如：ElementType.FIELD：说明自定义的注解可以用于类的变量ElementType.METHOD：说明自定义的注解可以用于类的方法ElementType.TYPE：说明自定义的注解可以用于类本身、接口或 enum类型等等… 还有很多5、 @Retention(xxx) 用来说明你自定义注解的生命周期，比如：@Retention(RetentionPolicy.RUNTIME)：表示注解可以一直保留到运行时，因此可以通过反射获取注解信息@Retention(RetentionPolicy.CLASS)：表示注解被编译器编译进 class文件，但运行时会忽略@Retention(RetentionPolicy.SOURCE)：表示注解仅在源文件中有效，编译时就会被忽略所以声明周期从长到短分别为：RUNTIME &gt; CLASS &gt; SOURCE ，一般来说，如果需要在运行时去动态获取注解的信息，还是得用RUNTIME，就像本文所用。 第二步：获取注解并对其进行验证(使用反射)public static String validate(Object object) throws IllegalAccessException{ // 首先通过反射获取object对象的类有哪些字段 // 对本文来说就可以获取到Student类的id、name、mobile三个字段 Field[] fields=object.getClass().getDeclaredFields(); // for循环逐个字段校验，看哪个字段上标了注解 for(Field field:fields){ // if判断：检查该字段上有没有标注了@Length注解 if(field.isAnnotationPresent(Length.class)){ // 通过反射获取到该字段上标注的@Length注解的详细信息 Length length=field.getAnnotation(Length.class); field.setAccessible(true);// 让我们在反射时能访问到私有变量 // 用过反射获取字段的实际值 int vaule=((String)field.get(object)).length(); // 将字段的实际值和注解上做标示的值进行比对 if(vaule&lt;length.min() || vaule&gt;length.max()) return length.errorMsg(); } } return null; }第三步：使用注解public class Student{ private Long id; private String name; @Length(min = 11,max = 11,errorMsg = &quot;电话号码的长度必须为11位&quot;) private String mobile;// 手机号码(11位) }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"排序算法","slug":"排序算法","date":"2020-02-23T15:00:26.000Z","updated":"2020-03-02T15:13:28.720Z","comments":true,"path":"2020/02/23/排序算法/","link":"","permalink":"http://yoursite.com/2020/02/23/排序算法/","excerpt":"","text":"稳定排序：如果a在b前面，且a=b，排序后a仍然在b前面，则为稳定排序，不稳定排序反之。原地排序：是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。 选择排序首先找到数组最小的元素，其次，将它和数组的第一个元素交换位置，接着，在剩下的元素中找到最小的元素，与第二个元素交换位置，以此类推，倒数第三个数交换完后，剩下最后两个数时，找到最小的数与倒数第二个数交换，排序完毕。 public class SelectSort { public static int[] selectSort(int[] a) { int n=a.length; for(int i=0;i&lt;n-1;i++){ int min=i; for(int j=i+1;j&lt;n;j++){ if(a[min]&gt;a[j]) min = j; } int temp = a[i]; a[i] = a[min]; a[min] = temp; } return a; } }性质：1、时间复杂度：O(n²) 2、空间复杂度：O(1) 3、非稳定排序 4、原地排序 插入排序联想打牌时将扑克牌排序，第一个数先不动，然后用第二个数与第一个数比较，看看插在第一个数的前面还是后面，接着拿第三个数与前面的数比较，看看插在什么位置，以此类推，到最后一个数看看插入到前面数的哪个位置，排序完成。 public class InsertSort { public static int[] insertSort(int[] arr) { if(arr == null || arr.length&lt;2) return arr; int len=arr.length; for(int i=1;i&lt;len;i++){ int temp=arr[i];//待插入的 int j=i; while(j&gt;0 &amp;&amp; temp&lt;arr[j-1]){ arr[j] = arr[j-1]; j--;//前面已经排好的数，通过比较腾出位置。 } arr[j]=temp; } return arr; } }性质：1、时间复杂度：O(n²) 2、空间复杂度：O(1) 3、稳定排序 4、原地排序 冒泡排序两两比较，最小的升上去。每次将第n大的交换到后面。 一、 public class BubbleSort { public static int[] bubbleSort(int[] arr) { if(arr==null || arr.length&lt;2) return arr; for(int i=0;i&lt;arr.length;i++){ for(int j=0;j&lt;arr.length-i-1;j++){ if(arr[j+1] &lt; arr[j]){ int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr; } } 二、 public class BubbleSort { public static int[] bubbleSort(int[] arr) { if(arr==null || arr.length&lt;2) return arr; for(int i=0;i&lt;arr.length-1;i++){ for(int j=arr.length-1;j&lt;i;j--){ if(arr[j-1] &gt; arr[j]){ int temp = arr[j-1]; arr[j] = arr[j-1]; arr[j-1] = temp; } } } return arr; } } 三、优化（假如在第一层遍历中，有次遍历两两元素都不发生交换，则说明数组有序） public class BubbleSort { public static int[] bubbleSort(int[] arr) { if(arr==null || arr.length&lt;2) return arr; for(int i=0;i&lt;arr.length;i++){ boolean flag = true; for(int j=0;j&lt;arr.length-i-1;j++){ if(arr[j+1] &lt; arr[j]){ flag = false; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } if(flag)//flag==true说明没发生交换，说明已经排好序了 break; } return arr; } }性质：1、时间复杂度：O(n²) 2、空间复杂度：O(1) 3、稳定排序 4、原地排序 希尔排序插入排序对不是基本有序和存在大量元素的数组进行排序效率不高，采用改变增量的方式对其插入排序进行优化，即希尔排序。 public class ShellSort { public static int shellSort(int[] arr) { if(arr==null || arr.length&lt;2) return arr; int d = arr.length / 2; while(d&gt;0){ shellInsert(arr,d); d /= 2; } } public static void shellInsert(int[] arr, int d) { for(int i=d;i&lt;arr.length;i++){ int temp=arr[i];//待插入的 int j=i-d; while(j&gt;=0 &amp;&amp; temp&lt;arr[j]){//从后向前，找到比其小的数的位置 arr[j+d] = arr[j];//向后挪动 j-=d; } if (j != i - d) //存在比其小的数 arr[j+d] = temp; } } }性质：1、时间复杂度：O(nlogn) 2、空间复杂度：O(1) 3、非稳定排序 4、原地排序 归并排序## 递归式归并排序 public class MergeSort { public static void mergeSort(int[] arr) { mSort(arr, 0, arr.length-1); } public static void mSort(int[] arr, int left, int right) { if(left &gt;= right) return; int mid=(left+right)/2; if(left&lt;right){ mSort(nums,left,mid); mSort(nums,mid+1,right); // 左右归并 merge(nums, left, mid, right); } } public static void merge(int[] nums, int left, int mid, int right) { int[] tmp = new int[right-left+1]; int i=left; int j=mid+1; int k=0; while(i&lt;=mid &amp;&amp; j&lt;=right){//按顺序放入temp if(nums[i] &lt;= nums[j]) temp[k++] = nums[i++]; else temp[k++] = nums[j++]; } //处理剩下的较长部分 while(i&lt;=mid) temp[k++] = nums[i++]; while(j&lt;=right) temp[k++] = nums[j++]; //temp中元素覆盖回去 for(int t=0;t&lt;temp.length;t++){ nums[t+left] = temp[t]; } } }性质：1、时间复杂度：O(nlog2n) 2、空间复杂度：O(n) 3、稳定排序 4、非原地排序 （T[n]=2T[n/2]+O(n)）O(n)为平分这次数组所用的时间，T[n/2]平分一半数组所用的时间 ，T[n] = O(nlogn)。 非递归式归并排序 public class MergeSort { public static int[] mergeSort(int[] arr) { int n = arr.length; // 子数组的大小分别为1，2，4，8... // 刚开始合并的数组大小是1，接着是2，接着4.... for (int i = 1; i &lt; n; i += i) { //进行数组进行划分 int left = 0; int mid = left + i - 1; int right = mid + i; //进行合并，对数组大小为 i 的数组进行两两合并 while (right &lt; n) { // 合并函数和递归式的合并函数一样 merge(arr, left, mid, right); left = right + 1; mid = left + i - 1; right = mid + i; } // 还有一些被遗漏的数组没合并，千万别忘了 // 因为不可能每个字数组的大小都刚好为 i if (left &lt; n &amp;&amp; mid &lt; n) { merge(arr, left, mid, n - 1); } } return arr; } } 快速排序public class QuickSort { public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } public static int[] quickSort(int[] arr, int left, int right) { if(left&lt;right){ //获取中轴元素所处的位置 int mid=partition(arr, left, right); arr=quickSort(arr,left,mid-1); arr=quickSort(arr,mid+1,right); } return arr; } private static int partition(int[] arr, int left, int right) { int pivot=arr[left];//基准元素 int pivotpoint = left; while(left &lt; right){ while(left&lt;right &amp;&amp; arr[right] &gt;= pivot) right--; while(left&lt;right &amp;&amp; arr[left] &lt;= pivot) left++; int temp=arr[right]; arr[right] = arr[left]; arr[left] = temp; } int temp2 = arr[left]; arr[left] = arr[pivotpoint]; arr[pivotpoint] = temp2; return left; } }性质：1、时间复杂度：平均复杂O(nlog2n) 最坏O(n²) 2、空间复杂度：O(logn) 3、非稳定排序 4、原地排序 堆排序首先建堆，然后进行堆排序。 public class HeapSort { public static int[] heapSort(int[] arr) { //构建二叉堆 int length=arr.length; for(int i=(length-2)/2;i&gt;=0;i--)//从最后一个有分支的节点开始修正 arr=downAdjust(arr,i,length); //堆排序,堆顶是最大的，最顶坐标是0 for(int i=length-1;i&gt;=1;i--){ int temp=arr[i]; arr[i]=arr[0]; arr[0]=temp; arr=downAdjust(arr,0,i); } return arr; } public static int[] downAdjust(int[] arr, int parent, int length) { //保存下沉的元素 int temp=arr[parent]; //左孩子 int child=2*parent+1; while(child &lt; length){ if(child+1&lt;length &amp;&amp; arr[child+1]&gt;arr[child]) child++;//右孩子比较大则保存右孩子 if(temp &gt;= arr[child]) break; arr[parent]=arr[child]; parent=child;//有孩子的话继续下沉 child=parent*2+1; } arr[parent]=temp; return arr; } }性质：1、时间复杂度：O(nlogn)（2^(i - 1) * (k - i)） 2、空间复杂度：O(1) 3、非稳定排序 4、原地排序 桶排序根据最大值和最小值进行划分区间，每个区间就是一个桶，对桶内元素进行排序，得到排序后的桶，在进行合并。 public class BucketSort{ public static void bucketSort(int[] arr) { if(arr==null || arr.length&lt;2) return arr; int len=arr.length; int max=arr[0],min=arr[0]; for(int i=1;i&lt;n;i++){ if(min&gt;arr[i]) min = arr[i]; else if(max&lt;arr[i]) max = arr[i]; } int d=max-min;//区间总长度 int bucketNum=d/5+1; ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum); for(int i=0;i&lt;bucketNum;i++){//初始化 bucketList.add(new LinkedList&lt;Integer&gt;()); } for(int i=0;i&lt;n;i++)//放入元素 bucketList.get((arr[i]-min)/d).add(arr[i]); for (int i = 0; i &lt; bucketNum; i++) { Collections.sort(bucketList.get(i)); } int k=0; for(int i=0;i&lt;bucketnum;i++){ for(Integer t:bucketList.get(i)){ arr[k++]=t; } } return arr; } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"LeetCode-14-最长公共前缀","slug":"LeetCode-14-最长公共前缀","date":"2020-02-22T10:08:16.000Z","updated":"2020-02-22T10:20:46.439Z","comments":true,"path":"2020/02/22/LeetCode-14-最长公共前缀/","link":"","permalink":"http://yoursite.com/2020/02/22/LeetCode-14-最长公共前缀/","excerpt":"","text":"class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) return &quot;&quot;; String prefix = strs[0]; for(int i=1;i&lt;strs.length;i++){ while(strs[i].indexOf(prefix) != 0){ prefix = prefix.substring(0,prefix.length()-1); if(prefix.isEmpty()) return &quot;&quot;; } } return prefix; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-11-盛最多水的容器","slug":"LeetCode-11-盛最多水的容器","date":"2020-02-22T09:37:30.000Z","updated":"2020-02-22T09:49:08.448Z","comments":true,"path":"2020/02/22/LeetCode-11-盛最多水的容器/","link":"","permalink":"http://yoursite.com/2020/02/22/LeetCode-11-盛最多水的容器/","excerpt":"","text":"暴力法class Solution { public int maxArea(int[] height) { int maxArea=0; for(int i=0;i&lt;height.length;i++){ for(int j=1;j&lt;height.length;j++) maxArea=Math.max(maxArea,Math.min(height[i],height[j])*(j-i)); } return maxArea; } }双指针一次遍历头尾指针，每次移动指向值小的指针，因为从左右两边缩，宽度减小了，期望面积增加，就得找到高更长的值，所以动值小的指针。 class Solution { public int maxArea(int[] height) { int maxArea=0; int left=0; int right=height.length-1; while(left&lt;right){ maxArea=Math.max(maxArea,Math.min(height[left],height[right])*(right-left)); if(height[left]&gt;height[right]) right--; else left++; } return maxArea; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-8-字符串转换整数","slug":"LeetCode-8-字符串转换整数","date":"2020-02-22T08:46:49.000Z","updated":"2020-02-22T08:57:44.621Z","comments":true,"path":"2020/02/22/LeetCode-8-字符串转换整数/","link":"","permalink":"http://yoursite.com/2020/02/22/LeetCode-8-字符串转换整数/","excerpt":"","text":"class Solution { public int myAtoi(String str) { int len = str.length(); int index=0; while(index&lt;len){ if(str.charAt(index) != &apos; &apos;) break;//去掉str前面的空格 index++; } if(index==len) return 0; int sigh=1; if(str.charAt(index) == &apos;+&apos;){ sigh=1; index++; }else if(str.charAt(index) == &apos;-&apos;){ sigh=-1; index++; } int res=0; while(index &lt; len){ char curchar = str.charAt(index); if(curchar&gt;&apos;9&apos; || curchar&lt;&apos;0&apos;) break; if(res&gt;Integer.MAX_VALUE/10 || (res==Integer.MAX_VALUE/10 &amp;&amp; (curchar-&apos;0&apos;)&gt;7))//7是2^31 - 1的个位数 return Integer.MAX_VALUE; if(res&lt;Integer.MIN_VALUE/10 || (res==Integer.MIN_VALUE/10 &amp;&amp; (curchar-&apos;0&apos;)&gt;8))//8是-2^31的个位数 return Integer.MIN_VALUE; res = res*10+sigh*(curchar-&apos;0&apos;); index++; } return res; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-7-整数反转","slug":"LeetCode-7-整数反转","date":"2020-02-22T08:01:04.000Z","updated":"2020-02-22T08:04:32.859Z","comments":true,"path":"2020/02/22/LeetCode-7-整数反转/","link":"","permalink":"http://yoursite.com/2020/02/22/LeetCode-7-整数反转/","excerpt":"","text":"class Solution { public int reverse(int x) { int res=0; while(x !=0 ){ int pop = x%10; //ans * 10 + pop &gt; MAX_VALUE if(res&gt;Integer.MAX_VALUE/10 || (res==Integer.MAX_VALUE/10 &amp;&amp; pop&gt;7))//7是2^31 - 1的个位数 return 0; //ans * 10 + pop &lt; MIN_VALUE if(res&lt;Integer.MIN_VALUE/10 || (res==Integer.MIN_VALUE/10 &amp;&amp; pop&lt;-8))//8是-2^31的个位数 return 0; res = res*10+pop; x /= 10; } return res; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-5-最长回文子串,9-回文整数","slug":"LeetCode-5-最长回文子串","date":"2020-02-21T13:59:10.000Z","updated":"2020-02-22T09:31:54.920Z","comments":true,"path":"2020/02/21/LeetCode-5-最长回文子串/","link":"","permalink":"http://yoursite.com/2020/02/21/LeetCode-5-最长回文子串/","excerpt":"","text":"5-最长回文子串 暴力法class Solution { public boolean isPalindrome(String s){ int len = s.length(); for(int i=0;i&lt;len/2;i++){ if(s.charAt(i) != s.charAt(len-i-1)) return false; } return true; } public String longestPalindrome(String s) { int max=0; String res=&quot;&quot;; int len = s.length(); for(int i=0;i&lt;len;i++){ for(int j=i+1;j&lt;=len;j++){ if(isPalindrome(s.substring(i,j)) &amp;&amp; max&lt;j-i){ max = j-i; res = s.substring(i,j); } } } return res; } } 动态规划（状态转移方程）class Solution { public String longestPalindrome(String s) { int len = s.length(); if(len&lt;2) return s; int start = 0; int maxlen = 1; boolean[][] dp=new boolean[len][len]; for(int i=0;i&lt;len;i++){ dp[i][i] = true; //因为一个字符必是回文串，即表格对角线是true } for(int j=1;j&lt;len;j++){ for(int i=0;i&lt;j;i++){ if(s.charAt(i) == s.charAt(j)){ if(j-i+1&lt;=3)//长度等于3或者等于2时,不用考虑dp[i+1][j-1]; dp[i][j] = true; else dp[i][j] = dp[i+1][j-1]; } else{ dp[i][j] = false; } if(dp[i][j]){ int curlen = j-i+1; if(curlen &gt; maxlen){ start = i; maxlen = curlen; } } } } return s.substring(start,start+maxlen); } }中心扩展法class Solution { public String longestPalindrome(String s) { int len=s.length(); if(len &lt; 2) return s; int maxlen = 1; String res=s.substring(0, 1);; for(int i=0;i&lt;len-1;i++){ String a=centerSpread(s,i,i); String b=centerSpread(s,i,i+1); String curmax = a.length()&gt;b.length()?a:b; if(curmax.length() &gt; maxlen){ maxlen = curmax.length(); res = curmax; } } return res; } public String centerSpread(String s, int left ,int right){ //left==right时，是以中心字母扩散 //left==right-1时，是以中心缝隙扩散 int len = s.length(); while(left&gt;= 0 &amp;&amp; right&lt;len){ if(s.charAt(left) == s.charAt(right)){ left--; right++; } else break; } return s.substring(left+1,right);//跳出循环时,s.charAt(left)!=s.charAt(right),所以不可取这两个端点 } }9-回文整数 反转整数（可能溢出）如果将整个整数反转，可能存在溢出的情况，所以需要考虑溢出情况，LeetCode这道题没有对溢出做出要求，所以就省去溢出检查的步骤。 class Solution { public boolean isPalindrome(int x) { if(x&lt;0) return false; int cur=x; int res=0; while(cur!=0){ int pop=cur%10; res = res *10+pop; cur = cur/10; } if(res == x) return true; return false; } }反转一半即可例如1221，只需将后半部分的21反转成12，然后与前半部分比较，相等就是回文整数，采用后半部分反转结果是否大于前半部分来判断是否反转整数的一半。 class Solution { public boolean isPalindrome(int x) { if(x&lt;0 || (x % 10 == 0 &amp;&amp; x != 0))//复数 || x最后一位是0,那么就只有0满足要求 return false; int pre_res=0; while(pre_res &lt; x){ int pop=x%10; pre_res = pre_res*10 + pop; x /= 10; } if(x == pre_res || x == pre_res/10)//12321这样的奇数,pre_res=123 return true; return false; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-2-两数相加","slug":"LeetCode-2-两数相加","date":"2020-02-20T14:06:05.000Z","updated":"2020-02-20T14:26:46.447Z","comments":true,"path":"2020/02/20/LeetCode-2-两数相加/","link":"","permalink":"http://yoursite.com/2020/02/20/LeetCode-2-两数相加/","excerpt":"","text":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode cur = dummy; int carry = 0; while(l1 != null || l2 != null){ int x = l1 == null ? 0:l1.val; int y = l2 == null ? 0:l2.val; int sum = x+y+carry; carry= (sum)/10;//所有加起来再除以10 sum = (sum)%10; cur.next = new ListNode(sum); cur = cur.next; if(l1 != null) l1=l1.next; if(l2 != null) l2=l2.next; } if(carry == 1) cur.next = new ListNode(1); return dummy.next; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java-Collection","slug":"Java-Collection","date":"2020-02-20T12:32:26.000Z","updated":"2020-02-20T13:20:40.165Z","comments":true,"path":"2020/02/20/Java-Collection/","link":"","permalink":"http://yoursite.com/2020/02/20/Java-Collection/","excerpt":"","text":"what is Collection 存储对象的容器。集合中可以存储任意类型的对象，并且长度可变。 advantageadvantage :长度可变，可以存储不同类型的对象。 method增加： 1：add() 将指定对象存储到容器中,add 方法的参数类型是Object 便于接收任意对象 2：addAll() 将指定集合中的元素添加到调用该方法和集合中 删除： 3：remove() 将指定的对象从集合中删除 4：removeAll() 将指定集合中的元素删除 修改 5：clear() 清空集合中的所有元素 判断 6：isEmpty() 判断集合是否为空 7：contains() 判断集合何中是否包含指定对象 8：containsAll() 判断集合中是否包含指定集合,使用equals()判断两个对象是否相等 获取: 9：int size() 返回集合容器的大小 转成数组 10： .toArray() 集合转换数组 遍历： 11：Iterator Iterator&lt;Object&gt; it = collection.iterator(); while(it.hasNext()) { Object obj = it.next(); System.out.println(obj); } 12：foreach for (Object obj : collection) { System.out.print(obj); } 13: for Object[] obj = collection.toArray(new Object[collection.size()]); for (int i=0; i&lt;obj.length; i++) { System.out.print(obj[i]); }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"LeetCode-169-多数元素","slug":"LeetCode-169-多数元素","date":"2020-02-19T11:54:00.000Z","updated":"2020-02-19T12:17:31.820Z","comments":true,"path":"2020/02/19/LeetCode-169-多数元素/","link":"","permalink":"http://yoursite.com/2020/02/19/LeetCode-169-多数元素/","excerpt":"","text":"方法一：哈希表class Solution { public int majorityElement(int[] nums) { HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int len = nums.length; for(int i=0;i&lt;len;i++){ int count = map.getOrDefault(nums[i],0); count++; map.put(nums[i], count); if(count &gt; len/2) return nums[i]; } return 0; } }方法二：，摩尔投票法class Solution { public int majorityElement(int[] nums) { int candidate = nums[0]; int count = 1; for(int i=1;i&lt;nums.length;i++){ if(count == 0){ count = 1; candidate = nums[i]; } else if(nums[i] == candidate) count++; else count--; } return candidate; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-160-相交链表","slug":"LeetCode-160","date":"2020-02-18T11:52:32.000Z","updated":"2020-02-18T12:10:27.013Z","comments":true,"path":"2020/02/18/LeetCode-160/","link":"","permalink":"http://yoursite.com/2020/02/18/LeetCode-160/","excerpt":"","text":"两个链表同时遍历，当其中一个到尾部NULL后，指向另一个链表的头部，继续遍历，直到两个节点相同即找到相交点。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode A = headA; ListNode B = headB; while(A != B){ if(A==null) A = headB; else A = A.next; if(B==null) B = headA; else B = B.next; } return A; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-155-最小栈","slug":"LeetCode-155-最小栈大子序列","date":"2020-02-17T10:44:22.000Z","updated":"2020-02-17T13:25:35.154Z","comments":true,"path":"2020/02/17/LeetCode-155-最小栈大子序列/","link":"","permalink":"http://yoursite.com/2020/02/17/LeetCode-155-最小栈大子序列/","excerpt":"","text":"可以用栈或者一个变量来保存最小值，这里使用了栈minstack; class MinStack { private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minstack; /** initialize your data structure here. */ public MinStack() { stack = new Stack&lt;Integer&gt;(); minstack = new Stack&lt;Integer&gt;(); } public void push(int x) { stack.push(x); if(!minstack.isEmpty()){ int top = minstack.peek(); if(top &gt;= x) minstack.push(x); }else{ minstack.push(x); } } public void pop() { int stack_pop = stack.pop();//stack要出栈 int minstack_pop = minstack.peek();//minstack判断栈顶元素是否是stack栈顶的值，是的话就出栈 if(stack_pop == minstack_pop) minstack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minstack.peek(); } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-152-乘积最大子序列","slug":"LeetCode-152-乘积最大子序列","date":"2020-02-16T11:32:46.000Z","updated":"2020-02-16T11:57:13.822Z","comments":true,"path":"2020/02/16/LeetCode-152-乘积最大子序列/","link":"","permalink":"http://yoursite.com/2020/02/16/LeetCode-152-乘积最大子序列/","excerpt":"","text":"方法一： class Solution { public int maxProduct(int[] nums) { int pre_max = nums[0]; int pre_min = nums[0]; int max_res=nums[0]; for(int i=1;i&lt;nums.length;i++){ int cur_max = Math.max(Math.max(nums[i]*pre_max,nums[i]*pre_min),nums[i]); int cur_min = Math.min(Math.min(nums[i]*pre_max,nums[i]*pre_min),nums[i]); max_res = Math.max(cur_max,max_res); pre_max = cur_max; pre_min = cur_min; } return max_res; } }方法二： class Solution { public int maxProduct(int[] nums) { int cur_max = nums[0]; int cur_min = nums[0]; int max_res=nums[0]; for(int i=1;i&lt;nums.length;i++){ if(nums[i]&lt;0){ int tmp = cur_max; cur_max = cur_min; cur_min = tmp; } cur_max = Math.max(nums[i]*cur_max,nums[i]); cur_min = Math.min(nums[i]*cur_min,nums[i]); max_res = Math.max(cur_max,max_res); } return max_res; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-53-最大子序和","slug":"LeetCode-53-最大子序和","date":"2020-02-16T10:33:18.000Z","updated":"2020-02-16T10:36:31.576Z","comments":true,"path":"2020/02/16/LeetCode-53-最大子序和/","link":"","permalink":"http://yoursite.com/2020/02/16/LeetCode-53-最大子序和/","excerpt":"","text":"判断nums[i]是否会对当前和产生增益效果，从而来取最大值。 class Solution { public int maxSubArray(int[] nums) { int current = nums[0]; int max = nums[0]; for(int i=1;i&lt;nums.length;i++){ current = Math.max(current+nums[i],nums[i]); max = Math.max(current,max); } return max; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-142-环形链表II","slug":"LeetCode-142-环形链表II","date":"2020-02-15T11:46:15.000Z","updated":"2020-02-15T12:00:17.118Z","comments":true,"path":"2020/02/15/LeetCode-142-环形链表II/","link":"","permalink":"http://yoursite.com/2020/02/15/LeetCode-142-环形链表II/","excerpt":"","text":"哈希表public class Solution { public ListNode detectCycle(ListNode head) { Set&lt;ListNode&gt; set=new HashSet&lt;&gt;(); while(head!=null){ if(!set.contains(head)) set.add(head); else return head; head=head.next; } return null; } }快慢指针找到相遇点后，可以证明出从头结点和从相遇点开始计算，每次一步，最终会在环的起点处相遇。 public class Solution { public ListNode getIntersect(ListNode head) { ListNode slow = head; ListNode fast = head; while(fast!=null &amp;&amp; fast.next!=null){ slow = slow.next; fast = fast.next.next; if(slow == fast) return slow; } return null; } public ListNode detectCycle(ListNode head) { if(head == null || head.next ==null) return null; ListNode Intersect = getIntersect(head); if (Intersect == null) { return null; } ListNode p1 = head; ListNode p2 = Intersect; while(p1 != p2){ p1 = p1.next; p2 = p2.next; } return p1; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-148-排序链表","slug":"LeetCode-148-排序链表","date":"2020-02-14T12:08:34.000Z","updated":"2020-02-14T12:22:07.457Z","comments":true,"path":"2020/02/14/LeetCode-148-排序链表/","link":"","permalink":"http://yoursite.com/2020/02/14/LeetCode-148-排序链表/","excerpt":"","text":"先将链表一直对半分，直到规模最小的两个节点，然后再两两对比排序合成最终的链表 递归法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { //根据快指针到达尾部，每次比快节点少走一步的慢节点到达中点来找到中间节点 public ListNode findMiddleNode(ListNode head){ ListNode slow = head; ListNode fast = head.next; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow; } public ListNode sortList(ListNode head) { if(head == null || head.next == null) return head; ListNode middle = findMiddleNode(head); ListNode right = sortList(middle.next);//首先对半分，递归一直到只有两个节点的右节点 middle.next = null;//拆分开 ListNode left = sortList(head);//左节点 return merge(left,right); } public ListNode merge(ListNode left,ListNode right){//合并 ListNode dummy = new ListNode(0); ListNode res = dummy; while(left != null &amp;&amp; right !=null){ if(left.val &gt; right.val){ res.next = right; right = right.next; } else{ res.next = left; left = left.next; } res = res.next; } if(right == null){ res.next = left; } else if(left == null){ res.next = right; } return dummy.next; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-147-对链表进行插入排序","slug":"LeetCode-147-对链表进行插入排序","date":"2020-02-13T13:53:33.000Z","updated":"2020-02-14T01:32:07.985Z","comments":true,"path":"2020/02/13/LeetCode-147-对链表进行插入排序/","link":"","permalink":"http://yoursite.com/2020/02/13/LeetCode-147-对链表进行插入排序/","excerpt":"","text":"对于遍历得到的每个原节点，查找放在新链表的哪个位置并操作。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { ListNode dummy = new ListNode(999);//创建一个新链表 while(head != null){ ListNode pre = dummy;//每次循环后都要把pre指向新链表的头结点dummy ListNode head_next = head.next;//将head的下一个节点保存下来 while(pre.next != null &amp;&amp; pre.next.val &lt; head.val){ pre = pre.next;//找到当前head要插入到pre后面的那个pre } head.next = pre.next;//把pre下个节点置于cur的下个节点 pre.next = head;//将head插入到pre后面 head=head_next;//head指向head.next } return dummy.next; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-146-LRU缓存机制","slug":"LeetCode-146-LRU缓存机制","date":"2020-02-13T10:29:08.000Z","updated":"2020-02-13T11:09:12.634Z","comments":true,"path":"2020/02/13/LeetCode-146-LRU缓存机制/","link":"","permalink":"http://yoursite.com/2020/02/13/LeetCode-146-LRU缓存机制/","excerpt":"","text":"哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。 class Node{ public int key,val; public Node next,prev; public Node(int key,int val){ this.key=key; this.val=val; } } class DoubleList{ private Node head,tail;//头尾虚节点 private int size; public DoubleList(){ head=new Node(0,0); tail=new Node(0,0); head.next=tail; tail.prev=head; size=0; } // 在链表头部添加节点 x public void addFist(Node x){ x.next = head.next; x.prev = head; head.next.prev=x; head.next=x; size++; } // 删除链表中的 x 节点（x 一定存在） public void remove(Node x){ x.prev.next=x.next; x.next.prev=x.prev; size--; } // 删除链表中最后一个节点，并返回该节点 public Node removeLast(){ if(tail.prev == head) return null; Node last=tail.prev; remove(last); return last; } // 返回链表长度 public int size(){ return size; } } class LRUCache { private HashMap&lt;Integer,Node&gt; map; private DoubleList cache; private int cap;// 最大容量 public LRUCache(int capacity) { this.cap=capacity; map = new HashMap&lt;&gt;(); cache = new DoubleList(); } public int get(int key) { if(!map.containsKey(key)) return -1; int val=map.get(key).val; put(key,val); return val; } public void put(int key, int value) { Node x=new Node(key,value); if(map.containsKey(key)){ // 删除旧的节点，新的插到头部 cache.remove(map.get(key)); cache.addFist(x); // 更新 map 中对应的数据 map.put(key,x); } else{ if(cap==cache.size()){ // 删除链表最后一个数据 Node last=cache.removeLast(); map.remove(last.key); } // 直接添加到头部 cache.addFist(x); map.put(key,x); } } } /** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-141-环形链表","slug":"LeetCode-141-环形链表","date":"2020-02-12T12:12:54.000Z","updated":"2020-02-13T13:58:03.132Z","comments":true,"path":"2020/02/12/LeetCode-141-环形链表/","link":"","permalink":"http://yoursite.com/2020/02/12/LeetCode-141-环形链表/","excerpt":"","text":"哈希表遍历链表,将节点存进哈希表，若出现重复节点，说明形成环。即判断是否遍历到前面已经遍历过的节点。时间复杂度：O(n)空间复杂度：O(n) public class Solution { public boolean hasCycle(ListNode head) { Set&lt;ListNode&gt; set=new HashSet&lt;&gt;(); while(head!=null){ if(!set.contains(head)) set.add(head); else return true; head=head.next; } return false; } }快慢指针时间复杂度：O(n)空间复杂度：O(1)想象成慢跑者和快跑者，如果是环，在跑n圈后他们最终会相遇。 public class Solution { public boolean hasCycle(ListNode head) { if(head == null || head.next ==null) return false; ListNode slow = head; ListNode fast = head.next; while(fast!=null &amp;&amp; fast.next!=null){ slow = slow.next; fast = fast.next.next; if(slow == fast) return true; } return false; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-128-最长连续序列","slug":"128-最长连续序列","date":"2020-02-06T10:14:25.000Z","updated":"2020-02-13T14:00:42.419Z","comments":true,"path":"2020/02/06/128-最长连续序列/","link":"","permalink":"http://yoursite.com/2020/02/06/128-最长连续序列/","excerpt":"","text":"暴力法：时间复杂度：O(n^3)空间复杂度：O(1)暴力算法仅使用了有限的整数，所以它用了常数级别的额外空间。 class Solution { public boolean helper(int[] nums,int n){ for(int i=0;i&lt;nums.length;i++){ if(nums[i] == n) return true; } return false; } public int longestConsecutive(int[] nums) { int res=0; for(int num:nums){ int current_length = 1; while(helper(nums,num+1)){ num++; current_length++; } res = Math.max(current_length,res); } return res; } }排序法：先排序，然后判断相邻数之间的关系。时间复杂度：O(nlgn)算法核心的 for循环恰好运行 n 次，所以算法的时间复杂度由 sort 函数的调用决定，通常会采用 O(nlgn) 时间复杂度的算法。空间复杂度：O(1)（或者 O(n)） class Solution { public int longestConsecutive(int[] nums) { if(nums.length == 0) return 0; Arrays.sort(nums); int res=1; int current_length = 1; for(int i=1;i&lt;nums.length;i++){ if(nums[i] != nums[i-1]){ if(nums[i] == nums[i-1]+1){ current_length++; } else{ res = Math.max(current_length,res); current_length = 1; } } } res = Math.max(current_length,res); return res; } }用set降低查找时间：这个优化算法与暴力算法仅有两处不同：这些数字用一个 HashSet 保存，实现 O(1) 时间的查询，同时，我们只对当前数字-1不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。 class Solution { public int longestConsecutive(int[] nums) { HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int num:nums){ set.add(num); } int res = 0; for(int num:set){ if(!set.contains(num-1)){ int current_length = 1; while(set.contains(num+1)){ num++; current_length++; } res = Math.max(current_length,res); } } return res; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"104-二叉树的最大深度","slug":"104-二叉树的最大深度","date":"2020-02-01T10:14:39.000Z","updated":"2020-02-01T10:29:05.702Z","comments":true,"path":"2020/02/01/104-二叉树的最大深度/","link":"","permalink":"http://yoursite.com/2020/02/01/104-二叉树的最大深度/","excerpt":"","text":"二叉树的深度 递归class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; else{ int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left,right)+1; } } } 用队列（BFS层次遍历）class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); int res=0; queue.add(root); while( !queue.isEmpty() ){ res++; int length = queue.size(); for(int i=0;i&lt;length;i++){ TreeNode r = queue.remove(); if(r.left != null) queue.add(r.left); if(r.right != null) queue.add(r.right); } } return res; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"机器学习","slug":"机器学习","date":"2020-01-20T03:37:28.000Z","updated":"2020-02-24T06:22:23.932Z","comments":true,"path":"2020/01/20/机器学习/","link":"","permalink":"http://yoursite.com/2020/01/20/机器学习/","excerpt":"","text":"机器学习发展史 AI学科分支 线性回归（一般用作预测）ACC：正确率 逻辑回归（一般用作分类）ReLu函数 https://www.jianshu.com/p/338afb1389c9 决策树决策树算法https://blog.csdn.net/qq_20412595/article/details/82048795 神经网络神经网络，它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。softmax函数logistic 回归是针对二分类问题，softmax则是针对多分类问题，logistic可看成softmax的特例。softmax用于多分类过程中，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解，从而来进行多分类！假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的softmax值就是在最后选取输出结点的时候，我们就可以选取概率最大（也就是值对应最大的）结点，作为我们的预测目标！ 深度学习-卷积神经网络 KNN算法分类算法，监督学习。概念：如果一个样本在特征空间中的k个最邻近的样本中的大多数属于某一个类别，则该样本也划分为这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者⼏个样本的类别来决定待分样本所属的类别。 K-Means算法kmeans算法又名k均值算法。其算法思想大致为：先从样本集中随机选取 kk 个样本作为簇中心，并计算所有样本与这 kk 个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中，对于新的簇计算各个簇的新的“簇中心”。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/categories/Machine-Learning/"}],"tags":[]},{"title":"88-合并两个有序数组","slug":"88-合并两个有序数组","date":"2020-01-18T08:05:32.000Z","updated":"2020-01-18T08:10:25.282Z","comments":true,"path":"2020/01/18/88-合并两个有序数组/","link":"","permalink":"http://yoursite.com/2020/01/18/88-合并两个有序数组/","excerpt":"","text":"class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int len1 = m-1; int len2 = n-1; int len = m+n-1; while(len1&gt;=0 &amp;&amp; len2&gt;=0){ //nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];两个数组的len1和len2进行比较，再决定放进nums1[len]是哪个数组的元素 if(nums1[len1]&gt;nums2[len2]) { nums1[len] = nums1[len1]; len--; len1--; } else{ nums1[len] = nums2[len2]; len--; len2--; } } System.arraycopy(nums2,0,nums1,0,len2+1); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"83-删除排序链表中的重复元素,82-删除排序链表中的重复元素II","slug":"83-删除排序链表中的重复元素-82-删除排序链表中的重复元素II","date":"2020-01-17T12:41:41.000Z","updated":"2020-01-17T13:50:53.748Z","comments":true,"path":"2020/01/17/83-删除排序链表中的重复元素-82-删除排序链表中的重复元素II/","link":"","permalink":"http://yoursite.com/2020/01/17/83-删除排序链表中的重复元素-82-删除排序链表中的重复元素II/","excerpt":"","text":"83. 删除排序链表中的重复元素 采用哑结点class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummy = new ListNode(9999); dummy.next = head; head = dummy; while(head.next != null){ if(head.val == head.next.val){ head.next = head.next.next; } else{ head = head.next; } } return dummy.next; } }不采用哑结点class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode res = head; while(res!=null &amp;&amp; res.next!=null){ if(res.val == res.next.val){ res.next = res.next.next; } else{ res = res.next; } } return head; } }#82. 删除排序链表中的重复元素 II 快慢指针class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null){ return head; } ListNode dummy = new ListNode(-1000); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy.next; while(fast != null){ while(fast.next != null &amp;&amp; fast.val == fast.next.val){ fast = fast.next; } if(slow.next == fast){ slow = slow.next; } else{ slow.next = fast.next; } fast = fast.next; } return dummy.next; } }递归class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null) return head; if(head.next != null &amp;&amp; head.val==head.next.val){ while(head.next != null &amp;&amp; head.val==head.next.val){ head = head.next; } return deleteDuplicates(head.next); } else{ head.next = deleteDuplicates(head.next); } return head; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"33-搜索旋转排序数组、81-搜索旋转排序数组(有重复项)","slug":"33-搜索旋转排序数组、81-搜索旋转排序数组-有重复项","date":"2020-01-16T10:36:19.000Z","updated":"2020-01-16T10:50:02.252Z","comments":true,"path":"2020/01/16/33-搜索旋转排序数组、81-搜索旋转排序数组-有重复项/","link":"","permalink":"http://yoursite.com/2020/01/16/33-搜索旋转排序数组、81-搜索旋转排序数组-有重复项/","excerpt":"","text":"区别两道题的区别是有无重复项，第一道中的if(nums[start] &lt;= nums[mid])被拆分成if(nums[start] == nums[mid]){//相当于去掉一个重复的干扰项 start++; continue; }和if(nums[start] &lt; nums[mid]) 33. 搜索旋转排序数组 class Solution { public int search(int[] nums, int target) { if(nums == null || nums.length == 0) return -1; int start = 0; int end = nums.length - 1; int mid; while(start &lt;= end){ mid = start + (end-start)/2; if(nums[mid] == target) return mid; if(nums[start] &lt;= nums[mid]){//等于是为了防止出现最后两项与逻辑不符的情况 if(nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target){ end = mid - 1; } else{ start = mid + 1; } } else{ if(nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target){ start = mid + 1; } else{ end = mid - 1; } } } return -1; } }81. 搜索旋转排序数组 II（重复元素） class Solution { public boolean search(int[] nums, int target) { if(nums == null || nums.length == 0) return false; int start = 0; int end = nums.length - 1; int mid; while(start &lt;= end){ mid = start + (end-start)/2; if(nums[mid] == target) return true; if(nums[start] == nums[mid]){//相当于去掉一个重复的干扰项。 start++; continue; } if(nums[start] &lt; nums[mid]){//这里不用=，因为前面已经判断过了 if(nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target){ end = mid - 1; } else{ start = mid + 1; } } else{ if(nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target){ start = mid + 1; } else{ end = mid - 1; } } } return false; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"80-删除排序数组中的重复项","slug":"80-删除排序数组中的重复项","date":"2020-01-16T09:53:58.000Z","updated":"2020-01-16T09:57:45.920Z","comments":true,"path":"2020/01/16/80-删除排序数组中的重复项/","link":"","permalink":"http://yoursite.com/2020/01/16/80-删除排序数组中的重复项/","excerpt":"","text":"删除数组中重复出现n次以上的元素 class Solution { public int removeDuplicates(int[] nums) { int i=0; for(int num:nums){ if(i&lt;k || num!=nums[i-k]){//k代表允许出现的最大次数 nums[i]=num; i++; } } return i; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"39-组合总和，77-组合，78-子集，90-子集II","slug":"39-组合总和，77-组合，78-子集","date":"2020-01-14T08:03:29.000Z","updated":"2020-01-19T14:45:31.087Z","comments":true,"path":"2020/01/14/39-组合总和，77-组合，78-子集/","link":"","permalink":"http://yoursite.com/2020/01/14/39-组合总和，77-组合，78-子集/","excerpt":"","text":"递归回溯39. 组合总和 class Solution { List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { if (candidates == null || candidates.length == 0 || target &lt; 0) { return lists; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); process(0, candidates, target, list); return lists; } private void process(int start, int[] candidates, int target, List&lt;Integer&gt; list) { //递归的终止条件 if (target &lt; 0) { return; } if (target == 0) { lists.add(new ArrayList&lt;&gt;(list)); } else { for (int i = start; i &lt; candidates.length; i++) { list.add(candidates[i]); //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始 process(i, candidates, target - candidates[i], list); list.remove(list.size() - 1); } } } }77. 组合 class Solution { private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { if(n &lt;= 0 || k &lt;= 0 || n &lt; k) return res; findCombination(n,k,1,new Stack&lt;&gt;()); return res; } private void findCombination(int n,int k,int first,List&lt;Integer&gt; pre){ if(pre.size()==k){ res.add(new ArrayList&lt;&gt;(pre)); } for(int i=first;i&lt;=n;i++){ pre.add(i); findCombination(n,k,i+1,pre); pre.remove(pre.size()-1); } } }78. 子集 class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { if(nums == null || nums.length ==0){ return res; } List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Combine(list,0,nums); return res; } public void Combine(List&lt;Integer&gt; list,int start,int[] nums){ res.add(new ArrayList(list)); for(int i=start;i&lt;nums.length;i++){ list.add(nums[i]); Combine(list,i+1,nums); list.remove(list.size()-1); } } }90. 子集 II class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { if(nums == null || nums.length == 0){ return res; } Arrays.sort(nums); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Combine(list,0,nums); return res; } public void Combine(List&lt;Integer&gt; list,int start,int[] nums){ res.add(new ArrayList&lt;Integer&gt;(list)); for(int i=start;i&lt;nums.length;i++){ if(i &gt; start &amp;&amp; nums[i-1] == nums[i]) continue; //在同一层中，第一次add无须考虑是否存在相同的值，但同一层中的后续add操作，如果添加相同的值，那么就是重复运算，这部分是可以去掉的。 list.add(nums[i]); Combine(list,i+1,nums); list.remove(list.size()-1); } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Hbase完全分布式搭建与实践","slug":"Hbase完全分布式搭建与实践","date":"2020-01-13T12:03:32.000Z","updated":"2020-01-13T13:09:45.144Z","comments":true,"path":"2020/01/13/Hbase完全分布式搭建与实践/","link":"","permalink":"http://yoursite.com/2020/01/13/Hbase完全分布式搭建与实践/","excerpt":"","text":"Hbase系统架构关于Hbase1、HBase是Google Bigtable的开源实现，它利用Hadoop HDFS作为其文件存储系统，利用Hadoop MapReduce来处理，HBase中的海量数据，利用Zookeeper作为协同服务。2、HBase是一种构建在HDFS之上的分布式、面向列的存储系统。1、Hmaster负责管理Hbase的元数据，表结构，表的Region信息负责表的创建，删除和修改负责为HRegionServer分配Region，分配后将元数据写入相应位置 2、HRegionServer含有多个HRegion处理Client端的读写请求（根据从HMaster返回的元数据找到对应的HRegionServer）管理Region的Split分裂、StoreFile的Compaction合并。 3、HRegion一个HRegion里可能有1个或多个StoreHRegionServer维护一个HLogHRegion是分布式存储和负载的最小单元。表通常被保存在多个HRegionServer的多个Region中 4、StoreStore是存储落盘的最小单元，由内存中的MemStore和磁盘中的若干StoreFile组成一个Store里有1个或多个StoreFile和一个memStore每个Store存储一个列族 Hbase完全分布式环境搭建虚拟机数量：3台操作系统：Ubuntu 14.04.3 实验环境及版本：Java：openjdk version “1.8.0_222”Hadoop：Hadoop 2.7.1Zookeeper:zookeeper-3.5.6.tar.gzHBase：hbase 1.1.2 环境搭建顺序 Hbase数据分析1、数据集介绍数据集来源http://dataju.cn/Dataju/web/datasetInstanceDetail/226数据包括IMDB网站上抓取的4973部电影28个属性信息,电影时间跨度超过100年和66个国家。属性包括：电影名称、评分、上映时间、上映国家、主要演员、语言、IMDB评分等。 2、数据集处理在第一列加上自动增长的序列，作为Hbase的row_key 3、导入数据集① 先下载.csv格式的数据到本地② 上传数据文件到Hdfs③ 在HBase里面创建一个movie表来存放电影数据④ 利用ImportTsv将HDFS上的数据文件导入到Hbase的movie表中 4、数据分析首先开启hbase shell,然后再Eclipse中编写java代码连接HBase分析数据Eclipse编写分析程序GitHub源码https://github.com/Eleven-is-cool/DataAnalyzeInHbaseEclipse中导入可视化分析相关包，编写代码分析！ BUG合集1、netstat -antp | grep 进程号 根据需要查看进程的访问端口2、单个节点处理Hmaster或者Hregionserver在regionServer上./hbase-daemon.sh start regionserver在master上执行：./hbase-daemon.sh start master3、进入hbase Shell后若出现ERROR: Can&#39;t get master address from ZooKeeper; znode data == null解决方法之一：ip和端口必须一样4、导入数据hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.separator=”,” -Dimporttsv.columns=HBASE_ROW_KEY,info:color,info:director_name,info: num_critic_for_reviews,info:duration,info:director_facebook_likes,info: actor_3_facebook_likes,info:actor_2_name,info:actor_1_facebook_likes hbase-csv1 /small.csv5、在Excel中添加第一列填充序号","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"'HDFS文件系统'","slug":"HDFS文件系统","date":"2020-01-13T10:32:24.000Z","updated":"2020-01-13T10:54:39.400Z","comments":true,"path":"2020/01/13/HDFS文件系统/","link":"","permalink":"http://yoursite.com/2020/01/13/HDFS文件系统/","excerpt":"","text":"分布式文件系统计算机集群结构分布式文件系统把文件分布存储到多个计算机节点上，成千上万的计算机节点构成计算机集群与之前使用多个处理器和专用高级硬件的并行化处理装置不同的是，目前的分布式文件系统所采用的计算机集群，都是由普通硬件构成的，这就大大降低了硬件上的开销 分布式文件系统的结构分布式文件系统在物理结构上是由计算机集群中的多个节点构成的，这些节点分为两类，一类叫“主节点”(Master Node)或者也被称为“名称结点”(NameNode)，另一类叫“从节点”（Slave Node）或者也被称为“数据节点”(DataNode) HDFS简介总体而言，HDFS要实现以下目标：●兼容廉价的硬件设备●流数据读写●大数据集●简单的文件模型●强大的跨平台兼容性HDFS特殊的设计，在实现上述优良特性的同时，也使得自身具有一些应用局限性，主要包括以下几个方面：●不适合低延迟数据访问●无法高效存储大量小文件●不支持多用户写入及任意修改文件 HDFS相关概念块HDFS默认一个块64MB，一个文件被分成多个块，以块作为存储单位块的大小远远大于普通文件系统，可以最小化寻址开销HDFS采用抽象的块概念可以带来以下几个明显的好处：● 支持大规模文件存储：文件以块为单位进行存储，一个大规模文件可以被分拆成若干个文件块，不同的文件块可以被分发到不同的节点上，因此，一个文件的大小不会受到单个节点的存储容量的限制，可以远远大于网络中任意节点的存储容量● 简化系统设计：首先，大大简化了存储管理，因为文件块大小是固定的，这样就可以很容易计算出一个节点可以存储多少文件块；其次，方便了元数据的管理，元数据不需要和文件块一起存储，可以由其他系统负责管理元数据● 适合数据备份：每个文件块都可以冗余存储到多个节点上，大大提高了系统的容错性和可用性 名称节点和数据节点名字节点-NameNode:管理元数据信息管理系统命名空间监听并处理请求心跳检测空间回收/冗余控制数据节点-DataNode:读写数据块报告状态-NameNode数据块复制-流水线 名称节点的数据结构在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），保存了两个核心的数据结构，即FsImage和EditLogFsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作名称节点记录了每个文件中各个块所在的数据节点的位置信息 名称节点运行期间EditLog不断变大的问题在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文件将会变得很大 虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用 如何解决？答案是：SecondaryNameNode第二名称节点 第二名称节点是HDFS架构中的一个组成部分，它是用来保存名称节点中对HDFS 元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上 SecondaryNameNode的工作情况：（1）SecondaryNameNode会定期和NameNode通信，请求其停止使用EditLog文件，暂时将新的写操作写到一个新的文件edit.new上来，这个操作是瞬间完成，上层写日志的函数完全感觉不到差别；（2）SecondaryNameNode通过HTTP GET方式从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下；（3）SecondaryNameNode将下载下来的FsImage载入到内存，然后一条一条地执行EditLog文件中的各项更新操作，使得内存中的FsImage保持最新；这个过程就是EditLog和FsImage文件合并；（4）SecondaryNameNode执行完（3）操作之后，会通过post方式将新的FsImage文件发送到NameNode节点上（5）NameNode将从SecondaryNameNode接收到的新的FsImage替换旧的FsImage文件，同时将edit.new替换EditLog文件，通过这个过程EditLog就变小了 HDFS体系结构HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点（NameNode）和若干个数据节点（DataNode）。名称节点作为中心服务器，负责管理文件系统的命名空间及客户端对文件的访问。集群中的数据节点一般是一个节点运行一个数据节点进程，负责处理文件系统客户端的读/写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作。每个数据节点的数据实际上是保存在本地Linux文件系统中的HDFS是一个部署在集群上的分布式文件系统，因此，很多数据需要通过网络进行传输所有的HDFS通信协议都是构建在TCP/IP协议基础之上的客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互名称节点和数据节点之间则使用数据节点协议进行交互客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求 HDFS存储原理作为一个分布式文件系统，为了保证系统的容错性和可用性，HDFS采用了多副本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上，如图3-5所示，数据块1被分别存放到数据节点A和C上，数据块2被存放在数据节点A和B上。这种多副本方式具有以下几个优点：（1）加快数据传输速度（2）容易检查数据错误（3）保证数据可靠性 数据存放第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点第二个副本：放置在与第一个副本不同的机架的节点上第三个副本：与第一个副本相同机架的其他节点上更多副本：随机节点 数据读取HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"Hadoop","slug":"Hadoop","date":"2020-01-13T09:16:22.000Z","updated":"2020-01-13T10:31:12.445Z","comments":true,"path":"2020/01/13/Hadoop/","link":"","permalink":"http://yoursite.com/2020/01/13/Hadoop/","excerpt":"","text":"Hadoop简介Hadoop是Apache软件基金会旗下的一个开源分布式计算平台，为用户提了系统底层细节透明的分布式基础架构。Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。Hadoop的核心是分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce。Hadoop最初是由Apache Lucene项目的创始人Doug Cutting开发的文本搜索库。Hadoop源自始于2002年的Apache Nutch项目——一个开源的网络搜索引擎并且也是Lucene项目的一部分。 Hadoop的特性Hadoop是一个能够对大量数据进行分布式处理的软件框架，并且是以一种可靠、高效、可伸缩的方式进行处理的，它具有以下几个方面的特性：高可靠性高效性高可扩展性高容错性成本低运行在Linux平台上支持多种编程语言 Hadoop的项目结构","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"大数据时代","slug":"大数据时代","date":"2020-01-13T05:26:42.000Z","updated":"2020-01-13T11:43:51.398Z","comments":true,"path":"2020/01/13/大数据时代/","link":"","permalink":"http://yoursite.com/2020/01/13/大数据时代/","excerpt":"","text":"大数据时代的来临三次信息化浪潮数据产生方式的变革促成大数据时代的来临。 传统关系型数据库面临的问题关系模型束缚对海量数据的快速访问能力传统按值定位相应的行的方式，影响快速访问的能力在海量数据下分区也无法显著改善性能 缺乏海量数据访问的灵活性不能对随机性的查询快速响应，需要DBA对系统调优 对非结构数据处理能力薄弱对多媒体数据只是停留在二进制代码文件的存储无法应对多媒体数据的识别、检索等深加工需求 海量数据导致存储成本、维护成本不断增加海量数据导致的存储和维护成本直线上升 大数据的特点①数据量大 ②数据类型繁多 ③处理速度快 ④价值密度低 大数据三大基石①Bigtable ②HDFS ③MapReduce NoSql通常，NoSQL数据库具有以下几个特点：（1）灵活的可扩展性（2）灵活的数据模型（3）与云计算紧密融合 NoSQL与关系数据库的比较总结（1）关系数据库优势：以完善的关系代数理论作为基础，有严格的标准，支持事务ACID四性，借助索引机制可以实现高效的查询，技术成熟，有专业公司的技术支持劣势：可扩展性较差，无法较好支持海量数据存储，数据模型过于死板、无法较好支持Web2.0应用，事务机制影响了系统的整体性能等 （2）NoSQL数据库优势：可以支持超大规模数据存储，灵活的数据模型可以很好地支持Web2.0应用，具有强大的横向扩展能力等劣势：缺乏数学理论基础，复杂查询性能不高，大都不能实现事务强一致性，很难实现数据完整性，技术尚不成熟，缺乏专业团队的技术支持，维护较困难等 NoSQL的四大类型","categories":[{"name":"分布式数据库","slug":"分布式数据库","permalink":"http://yoursite.com/categories/分布式数据库/"}],"tags":[]},{"title":"AlexNet","slug":"AlexNet","date":"2019-12-07T08:27:19.000Z","updated":"2020-01-13T11:01:21.926Z","comments":true,"path":"2019/12/07/AlexNet/","link":"","permalink":"http://yoursite.com/2019/12/07/AlexNet/","excerpt":"","text":"2012年AlexNet在ImageNet大赛上一举夺魁，开启了深度学习的时代，虽然后来大量比AlexNet更快速更准确的卷积神经网络结构相继出现，但是AlexNet作为开创者依旧有着很多值得学习参考的地方，它为后续的CNN甚至是R-CNN等其他网络都定下了基调，所以下面我们将从AlexNet入手，理解卷积神经网络的一般结构。Alexnet网络是由八层网络组成的，包括5层卷积层和3层全连接层，下面是详细的介绍：第一层：Alexnet的输入部分是224 * 224 * 3的彩色图片，经过预处理之后，变为227 * 227 * 3的大小，作为网络的输入的部分。这个图像被96个大小规格为11 * 11 * 3的卷积核，进行特征提取，96个卷积核分成2组（因为采用了2个GPU服务器进行处理），每组48个卷积核；因此，卷积核在移动的过程中会生成(227-11)/4+1=55个像素，注意这里提取到的特征图是彩色的。这样得到了96个55 * 55大小的特征图了，并且是RGB通道的.96个卷积核分成2组，每组48个卷积核。对应生成2组55 * 55 * 48的卷积后的像素层数据。这些像素层经过relu1单元的处理，生成激活像素层，尺寸仍为2组55 * 55 * 48的像素层数据。这些像素层经过pool运算(最大池化)的处理，池化运算的尺度为3 * 3，stride移动的步长为2，则池化后图像的尺寸为(55-3)/2+1=27。 即池化后像素的规模为27 * 27 * 96；然后经过归一化处理，归一化运算的尺度为5 * 5；第一卷积层运算结束后形成的像素层的规模为27 * 27 * 96。分别对应96个卷积核所运算形成。这96层像素层分为2组，每组48个像素层，每组在一个独立的GPU上进行运算。 第二层：输入数据为第一层输出的27 * 27 * 96的像素层，为便于后续处理，每幅像素层的左右两边和上下两边都要填充2个像素；27 * 27 * 96的像素数据分成27 * 27 * 48的两组像素数据，两组数据分别再两个不同的GPU中进行运算，每组像素数据被5 * 5 * 48的卷积核进行卷积运算，卷积核对每组数据的每次卷积都生成一个新的像素。在卷积的过程中，因为步长是1个像素。因此，卷积核在移动的过程中会生成(27-5+2 * 2)/1+1=27个像素。共有256个5 * 5 * 48卷积核；这256个卷积核分成两组，每组针对一个GPU中的27 * 27 * 48的像素进行卷积运算。会生成两组27 * 27 * 128个卷积后的像素层。这些像素层经过relu2单元的处理，生成激活像素层，尺寸仍为两组27 * 27 * 128的像素层。这些像素层经过pool运算(最大池化)的处理，池化运算的尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(27-3)/2+1=13。 即池化后像素的规模为2组13 * 13 * 128的像素层。最后经过归一化处理，归一化运算的尺度为5 * 5；第二卷积层运算结束后形成的像素层的规模为2组13 * 13 * 128的像素层。 第三层：第三层没有使用池化层，只有一个卷积层与另外一个激活函数。输入数据为第二层输出的2组13 * 13 * 128的像素层，为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；2组像素层数据都被送至2个不同的GPU中进行运算；因为在这里做了通道的合并，也就是一种串接操作，所以一个卷积核卷积的不再是单张显卡上的图像，而是两张显卡的图像串在一起之后的图像，串在一起之后的通道数就是256，所以卷积核的厚度为256，每个卷积核的尺寸是3 * 3 * 256，移动的步长是1个像素。运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13。2个GPU中共13 * 13 * 384个卷积后的像素层。这些像素层经过relu3单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 192像素层，共13 * 13 * 384个像素层。 第四层：没有使用池化层。输入数据为第三层输出的2组13 * 13 * 192的像素层；为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有192个卷积核，共384个，每个卷积核的尺寸是3 * 3 * 192。因此，运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13，2个GPU中共13 * 13 * 384个卷积后的像素层。这些像素层经过relu4单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 192像素层，共13 * 13 * 384个像素层。 第五层：输入数据为第四层输出的2组13 * 13 * 192的像素层；为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有128个卷积核，每个卷积核的尺寸是3 * 3 * 192。移动的步长是1个像素。因此，运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13。2个GPU中共13 * 13 * 256个卷积后的像素层。这些像素层经过relu5单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 128像素层，共13 * 13 * 256个像素层。2组13 * 13 * 128像素层分别在2个不同GPU中进行池化(pool)运算处理。池化运算的尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(13-3)/2+1=6。 即池化后像素的规模为两组6 * 6 * 128的像素层数据，共6 * 6 * 256规模的像素层数据。 第六层：第五层输出的6 * 6 * 256规模的像素层数据与第六层的4096个神经元进行全连接，然后经由relu6进行处理后生成4096个数据，再经过dropout6处理后输出4096个数据。 第七层：第六层输出的4096个数据与第七层的4096个神经元进行全连接，然后经由relu7进行处理后生成4096个数据，再经过dropout7处理后输出4096个数据。 第八层：第七层输出的4096个数据与第八层的1000个神经元进行全连接，经过训练后输出被训练的数值。 参考：https://blog.csdn.net/zyqdragon/article/details/72353420https://blog.csdn.net/chaipp0607/article/details/72847422","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/categories/Machine-Learning/"}],"tags":[]},{"title":"Neo4j","slug":"Neo4j","date":"2019-12-07T05:06:46.000Z","updated":"2019-12-07T08:34:06.410Z","comments":true,"path":"2019/12/07/Neo4j/","link":"","permalink":"http://yoursite.com/2019/12/07/Neo4j/","excerpt":"","text":"Neo4j简介Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。 Neo4j配置与启动首先需要下载neo4j-community-3.5.13-unix.tar.gz定位到文件所在位置，解压 tar -xf neo4j-community-3.5.13-unix.tar.gzmv neo4j-community-3.5.13-unix /home/hadoop/neo4j/home/hadoop/neo4j/bin/neo4j start打开浏览器输入：http://localhost:7474 Neo4j基础操作创建节点CREATE (&lt;node-name&gt;:&lt;label-name&gt;{ &lt;Property1-name&gt;:&lt;Property1-value&gt;...&lt;Propertyn-name&gt;:&lt;Propertyn-value&gt; }),...eg:CREATE (website:Demo{title:&#39;Code&#39;,begin:2019-10-1,end:2019-12-1}) 创建关系CREATE (&lt;node1-name&gt;:&lt;label1-name&gt;)-[(&lt;relationship-name&gt;:&lt;relationship-label-name&gt;)]-&gt;(&lt;node2-name&gt;:&lt;label2-name&gt;)eg:(Hong)-[:TASK_IN{roles:[&#39;boss&#39;]}]-&gt;(website) 获取有关节点与数据MATCH (&lt;node-name&gt;:&lt;label-name&gt;)单独使用无结果 返回结果RETURN &lt;node-name&gt;.&lt;Propertyn-name&gt;单独使用无结果 获取数据并返回结果eg:MATCH (a:Person)-[r:Person_Relate{detial: [&#39;classmate&#39;]}]-&gt;(b:Person) RETURN a,r,b创建节点与关系必须同时在一个命令行执行，否则需要MAtch先定位 ###实际例子 CREATE (website:Demo{title:’Code’,begin:2019-10-1,end:2019-12-1}), (Keanu:Person{name:’Keanu Reeves’,born:1994}), (Carrie:Person {name:’Carrie-Anne Moss’, born:1997}), (Laurence:Person {name:’Laurence Fishburne’, born:1999}), (Anndy:Person {name:’Andy Wachowski’, born:1995}), (Hong:Person{name:’Lan Hong’, born:1980}), (Hong)-[:TASK_IN{roles:[‘boss’]}]-&gt;(website), (Keanu)-[:TASK_IN{roles:[‘Front-end’]}]-&gt;(website), (Carrie)-[:TASK_IN{roles:[‘Back-end’]}]-&gt;(website), (Laurence)-[:TASK_IN{roles:[‘Front-end’]}]-&gt;(website), (Anndy)-[:TASK_IN{roles:[‘Back-end’]}]-&gt;(website), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Keanu), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Carrie), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Laurence), (Hong)-[:Person_Relate{detial:[‘Teacher and Student’]}]-&gt;(Anndy), (Carrie)-[:Person_Relate{detial:[‘classmate’]}]-&gt;(Anndy), (Keanu)-[:Person_Relate{detial:[‘classmate’]}]-&gt;(Anndy) match (a) return a查找所有关系 match (a:Person)-[r:Person_Relate{detial:[‘classmate’]}]-&gt;(b:Person) return a,r,b 查找关系为’classmate’的节点 match (a:Person)-[r:TASK_IN{roles:[‘Front-end’]}]-&gt;(b:Demo) return a,r,b 查找在项目中负责前端任务的人 待续…","categories":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://yoursite.com/categories/Neo4j/"}],"tags":[]},{"title":"Selenium框架","slug":"Selenium框架","date":"2019-11-24T06:10:29.000Z","updated":"2020-02-24T07:37:18.000Z","comments":true,"path":"2019/11/24/Selenium框架/","link":"","permalink":"http://yoursite.com/2019/11/24/Selenium框架/","excerpt":"","text":"SeleniumSelenium 是一款强大的基于浏览器的开源自动化测试工具，最初由Jason Huggins 于2004年在ThoughtWorks发起，它提供了一套简单易用的API，模拟浏览器的各种操作，方便各种Web应用的自动化测试。WebDriver通过调用浏览器提供的原生自动化API来驱动浏览器，解决了Selenium的很多疑难杂症。最终 Selenium 和 WebDriver 合并在一起，这就是 Selenium 2.0，有的地方也直接把它称作WebDriver。 selenium与chromedriver的下载cmd pip install selenium点击下载 chromedriver下载完路径放在环境变量上面的Path里面 。 界面化打开浏览器请求访问from selenium import webdriver driver = webdriver.Chrome() driver.get(detail_url) response = driver.page_source#获得页面源码 driver.quit()无界面化打开浏览器请求访问from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument(&quot;--proxy-server=http://{}&quot;.format(proxy)) #代理 chrome_options.add_argument(&apos;window-size=1920x3000&apos;) #指定浏览器分辨率 chrome_options.add_argument(&apos;--headless&apos;) #无界面化 chrome_options.add_argument(&apos;--disable-gpu&apos;) #谷歌文档提到需要加上这个属性来规避bug chrome_options.add_argument(&apos;blink-settings=imagesEnabled=false&apos;) #不加载图片, 提升速度 driver = webdriver.Chrome(chrome_options=chrome_options) driver.get(detail_url) response = driver.page_source driver.quit()定位页面元素单个元素find_element*多个元素find_elements* id复数定位find_elements_by_id() name复数定位find_elements_by_name() class复数定位find_elements_by_class_name() tag复数定位find_elements_by_tag_name() link复数定位find_elements_by_link_text() partial_link复数定位find_elements_by_partial_link_text() xpath复数定位find_elements_by_xpath() css复数定位find_elements_by_css_selector()eg:first_rows = driver.find_elements_by_css_selector(&quot;.aroundType li&quot;) 操作 from selenium.webdriver import ActionChain # 定位到某处并实现点击操作 ActionChains(driver).move_to_element(first_row).click().perform()#执行动作链actions.perform()","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"LeetCode-75-颜色分类","slug":"LeetCode-75-颜色分类","date":"2019-11-17T05:47:21.000Z","updated":"2019-11-24T07:33:39.807Z","comments":true,"path":"2019/11/17/LeetCode-75-颜色分类/","link":"","permalink":"http://yoursite.com/2019/11/17/LeetCode-75-颜色分类/","excerpt":"","text":"75. 颜色分类(荷兰国旗问题) 思路：沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。 算法初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0. 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2. 初始化当前考虑的元素序号 ：curr = 0. While curr &lt;= p2 : 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。 若 nums[curr] = 1 ：将指针curr右移。 class Solution { public void sortColors(int[] nums) { int p0=0; int p2=nums.length-1; int current=0; int tmp; while(current&lt;=p2){ if(nums[current]==2){ tmp=nums[p2]; nums[p2]=nums[current]; p2--; nums[current]=tmp; } else if(nums[current]==0){ tmp=nums[p0]; nums[p0]=nums[current]; p0++; nums[current]=tmp; current++; } else current++; } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-73-矩阵置零","slug":"LeetCode-73-矩阵置零","date":"2019-11-11T12:34:46.000Z","updated":"2019-11-24T07:33:39.874Z","comments":true,"path":"2019/11/11/LeetCode-73-矩阵置零/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-73-矩阵置零/","excerpt":"","text":"73. 矩阵置零 方法一：遍历矩阵，如果有0出现，则遍历该行该列，对不是0的位置赋予一个标志符，最后再遍历矩阵，把标志符变成0；时间复杂度：O((M×N)×(M+N))空间复杂度：O(1)O(1) class Solution { public void setZeroes(int[][] matrix) { int n = matrix.length; int m = matrix[0].length; int tmp=-100000; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ if(matrix[i][j]==0){ for(int k=0;k&lt;n;k++){ if(matrix[k][j]!=0) matrix[k][j] = tmp; } for(int z=0;z&lt;m;z++){ if(matrix[i][z]!=0) matrix[i][z] = tmp; } } } } for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ if(matrix[i][j]==tmp) matrix[i][j]=0; } } } }方法二：方法一不高效的地方在于我们会重复对同一行或者一列赋零。我们可以推迟对行和列赋零的操作。我们可以用每行和每列的第一个元素作为标记，这个标记用来表示这一行或者这一列是否需要赋零。这意味着对于每个节点不需要访问 M+N 个格子而是只需要对标记点的两个格子赋值。这些标签用于之后对矩阵的更新，如果某行的第一个元素为零就将整行置零，如果某列的第一个元素为零就将整列置零。class Solution { public void setZeroes(int[][] matrix) { int row = matrix.length; int col = matrix[0].length; boolean row0_flag = false; boolean col0_flag = false; // 第一行是否有零 for(int j = 0; j &lt; col; j++) { if(matrix[0][j] == 0) { row0_flag = true; break; } } // 第一列是否有零 for(int i = 0; i &lt; row; i++) { if(matrix[i][0] == 0) { col0_flag = true; break; } } // 把第一行第一列作为标志位 for(int i = 1; i &lt; row; i++) { for(int j = 1; j &lt; col; j++) { if(matrix[i][j] == 0) { matrix[i][0] = matrix[0][j] = 0; } } } // 置0 for(int i = 1; i &lt; row; i++) { for(int j = 1; j &lt; col; j++) { if(matrix[i][0] == 0 || matrix[0][j] == 0) { matrix[i][j] = 0; } } } if(row0_flag) { for(int j = 0; j &lt; col; j++) { matrix[0][j] = 0; } } if(col0_flag) { for(int i = 0; i &lt; row; i++) { matrix[i][0] = 0; } } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-69-x的平方根","slug":"LeetCode-69-x的平方根","date":"2019-11-11T11:59:13.000Z","updated":"2019-11-11T12:02:39.612Z","comments":true,"path":"2019/11/11/LeetCode-69-x的平方根/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-69-x的平方根/","excerpt":"","text":"69. x的平方根 思路：二分查找，所有的数都放在一起考虑，为了照顾到 00 把左边界设置为 00，为了照顾到 11 把右边界设置为 x // 2 + 1。 class Solution { public int mySqrt(int x) { long left=0; long right=x/2+1; while(left &lt; right){ long mid = left+(right-left+1)/2; long square = mid*mid; if(square &gt; x){ right = mid-1; } else{ left=mid; } } return (int)left; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-67-二进制求和","slug":"LeetCode-67-二进制求和","date":"2019-11-11T11:52:03.000Z","updated":"2019-11-11T11:58:20.545Z","comments":true,"path":"2019/11/11/LeetCode-67-二进制求和/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-67-二进制求和/","excerpt":"","text":"67. 二进制求和 class Solution { public String addBinary(String a, String b) { StringBuilder res = new StringBuilder(); int ca=0 ; for(int i=a.length()-1,j=b.length()-1;i&gt;=0||j&gt;=0;i--,j--){ int sum = ca; sum += (i&gt;=0? a.charAt(i)-&apos;0&apos;:0); sum += (j&gt;=0? b.charAt(j)-&apos;0&apos;:0); res.append(sum%2); ca = sum/2; } if(ca == 1) res.append(ca); return res.reverse().toString(); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-66-加一","slug":"LeetCode-66-加一","date":"2019-11-11T11:49:47.000Z","updated":"2019-11-11T11:51:13.831Z","comments":true,"path":"2019/11/11/LeetCode-66-加一/","link":"","permalink":"http://yoursite.com/2019/11/11/LeetCode-66-加一/","excerpt":"","text":"66. 加一 class Solution { public int[] plusOne(int[] digits) { int n = digits.length; for(int i=n-1;i&gt;=0;i--){ digits[i]++; digits[i] = digits[i] %10; if(digits[i] != 0) return digits; } digits = new int[digits.length + 1]; digits[0] = 1; return digits; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode-62、63-不同路径I、II，64-最小路径和","slug":"LeetCode-62、63-不同路径I、II","date":"2019-10-19T08:31:28.000Z","updated":"2019-11-11T10:18:04.885Z","comments":true,"path":"2019/10/19/LeetCode-62、63-不同路径I、II/","link":"","permalink":"http://yoursite.com/2019/10/19/LeetCode-62、63-不同路径I、II/","excerpt":"","text":"62. 不同路径思路： 动态规划，每个格子可能的路径等于左边格子加上面的格子。注意，对于第一行或者第一列，由于都是在边界，所以只能为 1。优化：可以用一维数组进行优化，当前的状态只跟上一行的状态和同一行左边的状态有关。所以我们只需要维护上一行的数组，和当前行的数组。 二维数组class Solution { public int uniquePaths(int m, int n) { int[][] path = new int[m][n]; for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i == 0 || j == 0) path[i][j] = 1; else{ path[i][j]= path[i-1][j] + path[i][j-1]; } } } return path[m-1][n-1]; } }一维数组class Solution { public int uniquePaths(int m, int n) { int[] cur = new int[n]; Arrays.fill(cur,1); for (int i = 1; i &lt; m;i++){ for (int j = 1; j &lt; n; j++){ cur[j] += cur[j-1] ; } } return cur[n-1]; } }63. 不同路径 II思路： 因为这道题有了障碍物,所以我们有障碍物的地方到不了就设置为0,注意,针对第一行,或者第一列要重新设置,考虑障碍物的情况! class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid == null) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] res = new int[m][n]; if(obstacleGrid[0][0] == 1) return 0; else res[0][0] = 1; for(int i=1;i&lt;n;i++){ if(obstacleGrid[0][i] != 1) res[0][i] = res[0][i-1]; } for(int j=1;j&lt;m;j++){ if(obstacleGrid[j][0] != 1) res[j][0] = res[j-1][0]; } for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ if(obstacleGrid[i][j] != 1) res[i][j] = res[i][j-1]+res[i-1][j]; } } return res[m-1][n-1]; } }64. 最小路径和 class Solution { public int minPathSum(int[][] grid) { int m=grid.length; int n=grid[0].length; for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i==0&amp;&amp;j==0) continue; else if(i==0) grid[i][j] = grid[i][j] + grid[i][j-1]; else if(j==0) grid[i][j] = grid[i][j] + grid[i-1][j]; else grid[i][j] = Math.min(grid[i][j-1],grid[i-1][j]) + grid[i][j]; } } return grid[m-1][n-1]; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 编写名为SimpleMap的类实现Map接口","slug":"Java-编写名为SimpleMap的类实现Map接口","date":"2019-10-17T02:42:30.000Z","updated":"2019-10-17T02:44:49.566Z","comments":true,"path":"2019/10/17/Java-编写名为SimpleMap的类实现Map接口/","link":"","permalink":"http://yoursite.com/2019/10/17/Java-编写名为SimpleMap的类实现Map接口/","excerpt":"","text":"import java.util.AbstractMap.SimpleEntry; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.ListIterator; import java.util.Map; import java.util.Set; public class SimpleMap implements Map{ private int size = 0; private int SLOT; private LinkedList[] bucket=new LinkedList[SLOT]; @Override public int size() { return size; } @Override public boolean isEmpty() { if(size==0) return false; else return true; } @Override public boolean containsKey(Object key) { int index = key.hashCode() % SLOT;//查找在哪个槽 if(index&lt;0)//不能为负数 index=-index; if(bucket[index] != null) return false; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator();//迭代器 while(iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if(entry.getKey().equals(key)) return true; } return false; } @Override public boolean containsValue(Object value) { for(int i=0;i&lt;SLOT;i++) { if(bucket[i] != null) { LinkedList linkedList = bucket[i]; Iterator iterator = linkedList.iterator(); while(iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if(entry.getKey().equals(value)) return true; } } } return false; } @Override public Object get(Object key) { int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; if (bucket[index] == null) return null; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) { SimpleEntry entry = (SimpleEntry) iterator.next(); if (entry.getKey().equals(key)) { return entry.getValue(); } } return null; } @Override public Object put(Object key, Object value) { int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; SimpleEntry entry = new SimpleEntry(key, value); Object prev = null; if (bucket[index] == null) bucket[index] = new LinkedList(); LinkedList list = bucket[index]; boolean found = false; ListIterator iterator = list.listIterator(); while (iterator.hasNext()) { SimpleEntry simpleEntry = (SimpleEntry) iterator.next(); if (simpleEntry.equals(entry)) {//一对一 found = true; prev = simpleEntry.getValue(); iterator.set(entry); break; } } if (!found) { size++; bucket[index].add(entry); } return prev; } @Override public Object remove(Object key) { SimpleEntry entry = null; int index = key.hashCode() % SLOT; if (index &lt; 0) index = -index; if (bucket[index] == null) return null; LinkedList linkedList = bucket[index]; Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) { SimpleEntry simpleEntry = (SimpleEntry) iterator.next(); if (simpleEntry.getKey().equals(key)) { entry = simpleEntry; iterator.remove(); size--; break; } } return entry; } @Override public void putAll(Map m) { Set set = m.entrySet(); for (Object object : set) { Map.Entry oo = (Map.Entry) object; put(oo.getKey(), oo.getValue()); } } @Override public void clear() { for (Object key : keySet()) { remove(key); } size = 0; } @Override public Set keySet() { Set set = new HashSet(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { set.add(((SimpleEntry) iterator.next()).getKey()); } } } return set; } @Override public Collection values() { List list = new ArrayList(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { list.add(((SimpleEntry) iterator.next()).getValue()); } } } return list; } @Override public Set&lt;Entry&gt; entrySet() { Set set = new HashSet(); for (int i = 0; i &lt; SLOT; i++) { if (bucket[i] != null) { Iterator iterator = bucket[i].iterator(); while (iterator.hasNext()) { set.add(((SimpleEntry) iterator.next())); } } } return set; } }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"LeetCode-61-旋转链表","slug":"LeetCode-61-旋转链表","date":"2019-10-07T07:10:23.000Z","updated":"2019-10-07T07:16:44.103Z","comments":true,"path":"2019/10/07/LeetCode-61-旋转链表/","link":"","permalink":"http://yoursite.com/2019/10/07/LeetCode-61-旋转链表/","excerpt":"","text":"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null || head.next == null) return head; int length = 1; ListNode old_tail = head; while(old_tail.next != null){//计算链表带数字的长度 length++; old_tail = old_tail.next; } old_tail.next = head;//构成环 ListNode new_tail = head; // 新的尾部 : (n - k % n - 1)th node // 新的头部 : (n - k % n)th node for(int i = 0;i&lt;length-k%length-1;i++){ new_tail = new_tail.next; } ListNode new_head = new_tail.next; new_tail.next = null;//断开环形成单链表 return new_head; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java 遍历字符串String","slug":"Java-遍历字符串String","date":"2019-10-04T06:35:57.000Z","updated":"2019-10-04T06:41:12.874Z","comments":true,"path":"2019/10/04/Java-遍历字符串String/","link":"","permalink":"http://yoursite.com/2019/10/04/Java-遍历字符串String/","excerpt":"","text":"Method One String str = &quot;The Lakers are Champions&quot;; for (int i = 0, n = str.length(); i &lt; n; i++) { char c = str.charAt(i); } Method Two char[] chars = str.toCharArray(); for (int i = 0, n = chars.length; i &lt; n; i++) { char c = chars[i]; }","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Python 线程池","slug":"Python-线程池","date":"2019-09-23T12:06:31.000Z","updated":"2020-02-24T07:37:17.990Z","comments":true,"path":"2019/09/23/Python-线程池/","link":"","permalink":"http://yoursite.com/2019/09/23/Python-线程池/","excerpt":"","text":"线程池的原理系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。 线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。 此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。 线程池的使用使用线程池来执行线程任务的步骤如下： ①调用 ThreadPoolExecutor 类的构造器创建一个线程池。 ②定义一个普通函数作为线程任务。 ③调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。 ④当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。 回调函数p.submit(这里异步调用).add_done_callback(回调函数)当线程任务完成后，程序会自动触发回调函数，回调函数会获得线程任务的返回值作为参数。在回调函数里，传进来的参数需要用.result()得到结果。 例子from concurrent.futures import ThreadPoolExecutor # 进程池模块 p = ThreadPoolExecutor(30) for page_url in page_url_list: p.submit(get_detail_page_url, page_url).add_done_callback(detail_page_parser) # 这里的回调函数拿到的是一个对象。 # 先把返回的res得到一个结果。即在前面加上一个res.result(),这个结果就是get_detail_page_url的返回。 p.shutdown() #shutdown() 方法，该方法将启动线程池的关闭序列。调用 shutdown() 方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。 #当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[]},{"title":"LeetCode 56.合并区间","slug":"LeetCode-56-合并区间","date":"2019-09-16T07:44:05.000Z","updated":"2019-09-16T09:51:01.381Z","comments":true,"path":"2019/09/16/LeetCode-56-合并区间/","link":"","permalink":"http://yoursite.com/2019/09/16/LeetCode-56-合并区间/","excerpt":"","text":"class Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals.length == 0 || intervals == null) return res.toArray(new int[0][]); Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] interval:intervals){ if(interval[0] &lt;= end){ end = Math.max(end, interval[1]); }else{ res.add(new int[]{start, end}); start = interval[0]; end = interval[1]; } } res.add(new int[]{start, end}); return res.toArray(new int[0][]); } }修改Arrays.sortclass Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals.length == 0 || intervals == null) return res.toArray(new int[0][]); Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] o1, int[] o2) { // TODO Auto-generated method stub return o1[0] - o2[0]; } }); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] interval:intervals){ if(interval[0] &lt;= end){ end = Math.max(end, interval[1]); }else{ res.add(new int[]{start, end}); start = interval[0]; end = interval[1]; } } res.add(new int[]{start, end}); return res.toArray(new int[0][]); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/categories/LeetCode/"}],"tags":[]},{"title":"Java input and inputMismatchException","slug":"Java-input-and-inputMismatchException","date":"2019-09-04T04:27:43.000Z","updated":"2019-09-04T04:47:56.945Z","comments":true,"path":"2019/09/04/Java-input-and-inputMismatchException/","link":"","permalink":"http://yoursite.com/2019/09/04/Java-input-and-inputMismatchException/","excerpt":"","text":"Java从控制台输入常用方法之一：import java.util.Scanner;Scanner scan = new Scanner(System.in);int a = scan.nextInt();String b = scan.nextLine();float c = scan.nextFloat(); 出现inputMismatchException：说明可能输入值与变量声明的数据类型不符合","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"git出现仓库间差异时，可以强推","slug":"git出现仓库间差异时，可以强推","date":"2019-09-03T00:41:06.000Z","updated":"2019-09-04T04:47:56.954Z","comments":true,"path":"2019/09/03/git出现仓库间差异时，可以强推/","link":"","permalink":"http://yoursite.com/2019/09/03/git出现仓库间差异时，可以强推/","excerpt":"","text":"git push -f origin master目前还不知道有什么弊端","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"使用git将本地仓库推送到GitHub仓库","slug":"用git将本地仓库推送到GitHub仓库","date":"2019-08-29T04:08:29.000Z","updated":"2020-03-23T12:19:54.660Z","comments":true,"path":"2019/08/29/用git将本地仓库推送到GitHub仓库/","link":"","permalink":"http://yoursite.com/2019/08/29/用git将本地仓库推送到GitHub仓库/","excerpt":"","text":"创建本地仓库mkdir filenamecd filename 初始化仓库git init然后打开仓库所在的文件夹对文件进行操作 将文件推送本地仓库git status此时会列出带红色的文件名git add 文件名git commit -m &quot;描述&quot;git status提示nothing to commit, working tree clean说明已经没有文件在暂存区和工作区了 推送到远程仓库先到GitHub上创建一个新仓库,复制仓库地址git remote add origin 仓库地址git pull origin master --allow-unrelated-histories这一步是为了本地仓库同步远程仓库的README.mdgit push -u origin master第一次推送 对文件修改后，再次推送到远程仓库git statusgit add filenamegit commit -m &quot;描述&quot;git statusgit push origin master推送成功","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"搭建hexo，部署到GitHub仓库","slug":"搭建hexo，部署到GitHub仓库","date":"2019-08-27T13:48:10.000Z","updated":"2019-08-29T03:43:29.846Z","comments":true,"path":"2019/08/27/搭建hexo，部署到GitHub仓库/","link":"","permalink":"http://yoursite.com/2019/08/27/搭建hexo，部署到GitHub仓库/","excerpt":"","text":"首先下载node.js点击进入：https://nodejs.org/en/检查是否下载成功 接着安装hexo博客框架安装hexo博客框架，需要借助npm包管理器来安装，国内镜像安装比较慢，先用npm下载cnpm，就是淘宝源，利用淘宝源来安装加快下载速度。检查是否下载成功接下来利用cnpm安装hexo框架检查是否安装成功 初始化hexo博客查看路径创建一个新文件夹然后进入该路径初始化博客查看blog文件夹，是否下载成功启动博客在浏览器访问一下，访问成功，说明博客已经在本地成功搭建创建一篇博客，先关闭博客。查看路径下的文件对于博客内容，可以在文件夹里用typora打开编辑，然后保存刷新即可。接着清理生成再次启动博客刷新浏览器页面就可以看到你刚刚的那篇博文 将博客部署到远端，使别人能访问在blog目录下装一个git部署插件接下来对blog文件夹里的_config.yml进行添加说明，可以选择用文本打开，滚到最底部，将deploy下面的内容补上去，每一行开头前两个空格，冒号后面一个空格，repo是你仓库的地址。保存退出，接着部署到远端中间需要输入你GitHub的账户密码接下来就可以根据你的仓库名（name.github.io）访问你的博客了","categories":[],"tags":[]}]}